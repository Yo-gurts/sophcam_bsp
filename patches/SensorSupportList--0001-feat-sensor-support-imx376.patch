From 19e50106aa3219fc152483c33d5cc1cd5b66616f Mon Sep 17 00:00:00 2001
From: "shihuai.zhang" <shihuai.zhang@sophgo.com>
Date: Thu, 15 Jan 2026 21:01:52 +0800
Subject: [PATCH] feat:(sensor): support imx376

Change-Id: Ic95d18355cc99b96033d60a65a015e37099e436d
---
 Makefile                        |    3 +
 package.yaml                    |    2 +
 sensor.mk                       |    1 +
 sensor_cfg/sensor_cfg.c         |   12 +
 sensor_cfg/sensor_cfg.h         |    2 +
 sony_imx376/Makefile            |   37 +
 sony_imx376/imx376_cmos.c       | 1116 +++++++++++++++++++++++++++++++
 sony_imx376/imx376_cmos_ex.h    |   93 +++
 sony_imx376/imx376_cmos_param.h |  203 ++++++
 sony_imx376/imx376_sensor_ctl.c |  526 +++++++++++++++
 10 files changed, 1995 insertions(+)
 create mode 100644 sony_imx376/Makefile
 create mode 100644 sony_imx376/imx376_cmos.c
 create mode 100644 sony_imx376/imx376_cmos_ex.h
 create mode 100644 sony_imx376/imx376_cmos_param.h
 create mode 100644 sony_imx376/imx376_sensor_ctl.c

diff --git a/Makefile b/Makefile
index 9c6fe49..7f62544 100644
--- a/Makefile
+++ b/Makefile
@@ -246,6 +246,9 @@ sony_imx327_sublvds:
 sony_imx335:
 	$(call MAKE_SENSOR, ${@})
 
+sony_imx376:
+	$(call MAKE_SENSOR, ${@})
+
 sony_imx412:
 	$(call MAKE_SENSOR, ${@})
 
diff --git a/package.yaml b/package.yaml
index 7536bf4..99bef98 100644
--- a/package.yaml
+++ b/package.yaml
@@ -159,6 +159,7 @@ build_config:
     - sony_imx327_fpga
     - sony_imx327_sublvds
     - sony_imx335
+    - sony_imx376
     - sony_imx412
     - sony_imx415
     - sony_imx585
@@ -246,6 +247,7 @@ source_file:
   - sony_imx327_fpga/*.c ? <CONFIG_SENSOR_SONY_IMX327_FPGA>
   - sony_imx327_sublvds/*.c ? <CONFIG_SENSOR_SONY_IMX327_SUBLVDS>
   - sony_imx335/*.c ? <CONFIG_SENSOR_SONY_IMX335>
+  - sony_imx376/*.c ? <CONFIG_SENSOR_SONY_IMX376>
   - sony_imx412/*.c ? <CONFIG_SENSOR_SONY_IMX412>
   - sony_imx415/*.c ? <CONFIG_SENSOR_SONY_IMX415>
   - sony_imx585/*.c ? <CONFIG_SENSOR_SONY_IMX585>
diff --git a/sensor.mk b/sensor.mk
index cd1bef2..40d1926 100644
--- a/sensor.mk
+++ b/sensor.mk
@@ -78,6 +78,7 @@ $(eval $(call SENSOR_MODULE,SENSOR_SONY_IMX327_2L,sony_imx327_2L))
 $(eval $(call SENSOR_MODULE,SENSOR_SONY_IMX327_FPGA,sony_imx327_fpga))
 $(eval $(call SENSOR_MODULE,SENSOR_SONY_IMX327_SUBLVDS,sony_imx327_sublvds))
 $(eval $(call SENSOR_MODULE,SENSOR_SONY_IMX335,sony_imx335))
+$(eval $(call SENSOR_MODULE,SENSOR_SONY_IMX376,sony_imx376))
 $(eval $(call SENSOR_MODULE,SENSOR_SONY_IMX412,sony_imx412))
 $(eval $(call SENSOR_MODULE,SENSOR_SONY_IMX415,sony_imx415))
 $(eval $(call SENSOR_MODULE,SENSOR_SONY_IMX585,sony_imx585))
diff --git a/sensor_cfg/sensor_cfg.c b/sensor_cfg/sensor_cfg.c
index accc9ec..8e14002 100644
--- a/sensor_cfg/sensor_cfg.c
+++ b/sensor_cfg/sensor_cfg.c
@@ -240,6 +240,10 @@ CVI_S32 cvi_sns_getsize(CVI_U32 dev_num, SENSOR_CFG_S *sensor_cfg)
 		sns_cfg->u32ImageWigth[dev_num] = 2560;
 		sns_cfg->u32ImageHeight[dev_num] = 1600;
 		break;
+	case SONY_IMX376_2L_MIPI_5M_30FPS_10BIT:
+		sns_cfg->u32ImageWigth[dev_num] = 2560;
+		sns_cfg->u32ImageHeight[dev_num] = 1920;
+		break;
 	case SONY_IMX675_MIPI_5M_30FPS_12BIT:
 	case SONY_IMX675_MIPI_5M_25FPS_12BIT_WDR2TO1:
 		sns_cfg->u32ImageWigth[dev_num] = 2560;
@@ -443,6 +447,7 @@ static CVI_S32 cvi_sns_getbayerformat(CVI_U32 dev_num, SENSOR_CFG_S *sensor_cfg)
 	case SONY_IMX335_MIPI_5M_60FPS_10BIT:
 	case SONY_IMX347_MIPI_4M_60FPS_12BIT:
 	case SONY_IMX347_MIPI_4M_30FPS_12BIT_WDR2TO1:
+	case SONY_IMX376_2L_MIPI_5M_30FPS_10BIT:
 	case SONY_IMX385_MIPI_2M_30FPS_12BIT:
 	case SONY_IMX385_MIPI_2M_30FPS_12BIT_WDR2TO1:
 	case SONY_IMX412_MIPI_12M_30FPS_12BIT:
@@ -831,6 +836,8 @@ CVI_S32 cvi_sns_getispattr(CVI_U32 dev_num, SENSOR_CFG_S *sensor_cfg)
 	case SMS_SC1330_MIPI_1M_30FPS_10BIT_SLAVE:
 	case SMS_SC202L_2L_MASTER_MIPI_2M_30FPS_10BIT:
 	case SMS_SC202L_2L_SLAVE_MIPI_2M_30FPS_10BIT:
+	case IMGDS_MIS40C1_MIPI_4M_20FPS_2L_10BIT:
+	case SONY_IMX376_2L_MIPI_5M_30FPS_10BIT:
 		sns_cfg->u8LaneNumber[dev_num] = 2;
 		break;
 	default:
@@ -1450,6 +1457,11 @@ CVI_S32 cvi_sns_getsnsobj(CVI_U32 dev_num, SENSOR_CFG_S *sensor_cfg)
 		pSnsObj = &stSnsImx335_Obj;
 		break;
 #endif
+#if defined(CONFIG_SENSOR_SONY_IMX376)
+	case SONY_IMX376_2L_MIPI_5M_30FPS_10BIT:
+		pSnsObj = &stSnsImx376_Obj;
+		break;
+#endif
 #if defined(CONFIG_SENSOR_SONY_IMX347)
 	case SONY_IMX347_MIPI_4M_60FPS_12BIT:
 	case SONY_IMX347_MIPI_4M_30FPS_12BIT_WDR2TO1:
diff --git a/sensor_cfg/sensor_cfg.h b/sensor_cfg/sensor_cfg.h
index 8f2eeb5..c7bc751 100644
--- a/sensor_cfg/sensor_cfg.h
+++ b/sensor_cfg/sensor_cfg.h
@@ -193,6 +193,7 @@ extern ISP_SNS_OBJ_S stSnsImx327_Sublvds_Obj;
 extern ISP_SNS_OBJ_S stSnsImx334_Obj;
 extern ISP_SNS_OBJ_S stSnsImx335_Obj;
 extern ISP_SNS_OBJ_S stSnsImx347_Obj;
+extern ISP_SNS_OBJ_S stSnsImx376_Obj;
 extern ISP_SNS_OBJ_S stSnsImx385_Obj;
 extern ISP_SNS_OBJ_S stSnsImx412_Obj;
 extern ISP_SNS_OBJ_S stSnsImx415_Obj;
@@ -453,6 +454,7 @@ typedef enum _SNS_TYPE_E {
 	SONY_IMX335_MIPI_4M_60FPS_10BIT = 0X28043C40,
 	SONY_IMX335_MIPI_5M_60FPS_10BIT = 0X28045440,
 	SONY_IMX347_MIPI_4M_60FPS_12BIT = 0X28083C40,
+	SONY_IMX376_2L_MIPI_5M_30FPS_10BIT = 0X28445320,
 	SONY_IMX385_MIPI_2M_30FPS_12BIT = 0X280C3340,
 	SONY_IMX662_MIPI_2M_30FPS_10BIT = 0X28203320,
 	SONY_IMX675_MIPI_4M_30FPS_12BIT = 0X28243B40,
diff --git a/sony_imx376/Makefile b/sony_imx376/Makefile
new file mode 100644
index 0000000..a847164
--- /dev/null
+++ b/sony_imx376/Makefile
@@ -0,0 +1,37 @@
+SHELL = /bin/bash
+ifeq ($(PARAM_FILE), )
+	PARAM_FILE=$(MW_PATH)/Makefile.param
+	include $(PARAM_FILE)
+endif
+
+SDIR = $(PWD)
+SRCS = $(wildcard $(SDIR)/*.c)
+INCS = -I$(MW_INC) -I$(ISP_INC) -I$(VI_INC) -I$(KERNEL_INC) -I$(VI_INC) -I./include
+INCS += -I../sensor_i2c
+OBJS = $(SRCS:.c=.o)
+DEPS = $(SRCS:.c=.d)
+TARGET_A = $(MW_LIB)/libsns_imx376.a
+TARGET_SO = $(MW_LIB)/libsns_imx376.so
+
+EXTRA_CFLAGS = $(INCS) $(PROJ_CFLAGS)
+EXTRA_LDFLAGS =
+
+.PHONY : clean all
+all : $(TARGET_A) $(TARGET_SO)
+
+$(SDIR)/%.o: $(SDIR)/%.c
+	@$(CC) $(DEPFLAGS) $(CFLAGS) $(EXTRA_CFLAGS) -c $< -o $@
+	@echo [$(notdir $(CC))] $(notdir $@)
+
+$(TARGET_A): $(OBJS)
+	@$(AR) $(ARFLAGS) $@ $(OBJS)
+	@echo -e $(YELLOW)[LINK]$(END)[$(notdir $(AR))] $(notdir $@)
+
+$(TARGET_SO): $(OBJS)
+	@$(LD) $(LDFLAGS) $(EXTRA_LDFLAGS) -o $@ --start-group $(OBJS) --end-group
+	@echo -e $(GREEN)[LINK]$(END)[$(notdir $(LD))] $(notdir $@)
+
+clean:
+	@rm -f $(OBJS) $(DEPS) $(TARGET_A) $(TARGET_SO)
+
+-include $(DEPS)
\ No newline at end of file
diff --git a/sony_imx376/imx376_cmos.c b/sony_imx376/imx376_cmos.c
new file mode 100644
index 0000000..6e7763d
--- /dev/null
+++ b/sony_imx376/imx376_cmos.c
@@ -0,0 +1,1116 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <errno.h>
+#include <unistd.h>
+#include <cvi_type.h>
+#include <cvi_comm_video.h>
+#include "cvi_debug.h"
+#include "cvi_comm_sns.h"
+#include "cvi_sns_ctrl.h"
+#include "cvi_ae_comm.h"
+#include "cvi_awb_comm.h"
+#include "cvi_ae.h"
+#include "cvi_awb.h"
+#include "cvi_isp.h"
+
+#include "imx376_cmos_ex.h"
+#include "imx376_cmos_param.h"
+
+#define DIV_0_TO_1(a)   ((0 == (a)) ? 1 : (a))
+#define DIV_0_TO_1_FLOAT(a) ((((a) < 1E-10) && ((a) > -1E-10)) ? 1 : (a))
+#define IMX376_ID 376
+
+#define SENSOR_IMX376_5M_WIDTH  2560
+#define SENSOR_IMX376_5M_HEIGHT 1920
+#define IMX376_I2C_ADDR_1 0x1A
+#define IMX376_I2C_ADDR_2 0x10
+#define IMX376_I2C_ADDR_IS_VALID(addr)      ((addr) == IMX376_I2C_ADDR_1 || (addr) == IMX376_I2C_ADDR_2)
+
+/****************************************************************************
+ * global variables                                                         *
+ ****************************************************************************/
+
+ISP_SNS_STATE_S *g_pastImx376[VI_MAX_PIPE_NUM] = {CVI_NULL};
+SNS_COMBO_DEV_ATTR_S *g_pastImx376ComboDevArray[VI_MAX_PIPE_NUM] = {CVI_NULL};
+
+#define IMX376_SENSOR_GET_CTX(dev, pstCtx)   (pstCtx = g_pastImx376[dev])
+#define IMX376_SENSOR_SET_CTX(dev, pstCtx)   (g_pastImx376[dev] = pstCtx)
+#define IMX376_SENSOR_RESET_CTX(dev)         (g_pastImx376[dev] = CVI_NULL)
+#define IMX376_SENSOR_SET_COMBO(dev, pstCtx)   (g_pastImx376ComboDevArray[dev] = pstCtx)
+#define IMX376_SENSOR_GET_COMBO(dev, pstCtx)   (pstCtx = g_pastImx376ComboDevArray[dev])
+
+ISP_SNS_COMMBUS_U g_aunImx376_BusInfo[VI_MAX_PIPE_NUM] = {
+	[0] = { .s8I2cDev = 2},
+	[1 ... VI_MAX_PIPE_NUM - 1] = { .s8I2cDev = -1}
+};
+
+ISP_SNS_COMMADDR_U g_aunImx376_AddrInfo[VI_MAX_PIPE_NUM] = {
+	[0] = { .s8I2cAddr = 0},
+	[1 ... VI_MAX_PIPE_NUM - 1] = { .s8I2cAddr = -1}
+};
+
+CVI_U16 g_au16Imx376_GainMode[VI_MAX_PIPE_NUM] = {0};
+
+IMX376_STATE_S g_astImx376_State[VI_MAX_PIPE_NUM] = {{0} };
+ISP_SNS_MIRRORFLIP_TYPE_E g_aeImx376_MirrorFip[VI_MAX_PIPE_NUM] = {0};
+
+/****************************************************************************
+ * local variables and functions                                            *
+ ****************************************************************************/
+static ISP_FSWDR_MODE_E genFSWDRMode[VI_MAX_PIPE_NUM] = {
+	[0 ... VI_MAX_PIPE_NUM - 1] = ISP_FSWDR_NORMAL_MODE
+};
+
+static CVI_U32 gu32MaxTimeGetCnt[VI_MAX_PIPE_NUM] = {0};
+static CVI_U32 g_au32InitExposure[VI_MAX_PIPE_NUM]  = {0};
+static CVI_U32 g_au32LinesPer500ms[VI_MAX_PIPE_NUM] = {0};
+static CVI_U16 g_au16InitWBGain[VI_MAX_PIPE_NUM][3] = {{0} };
+static CVI_U16 g_au16SampleRgain[VI_MAX_PIPE_NUM] = {0};
+static CVI_U16 g_au16SampleBgain[VI_MAX_PIPE_NUM] = {0};
+static CVI_S32 cmos_get_wdr_size(VI_PIPE ViPipe, ISP_SNS_ISP_INFO_S *pstIspCfg);
+/*****Imx376 Lines Range*****/
+#define IMX376_FULL_LINES_MAX  (0xFFFFF)
+#define IMX376_VMAX_8M25_LINEAR	3184
+
+/*****Imx376 Register Address*****/
+#define IMX376_HOLD_ADDR        0x0104
+
+#define IMX376_SHR_HIGH_ADDR        0x0202 //shutter time
+#define IMX376_SHR_LOW_ADDR        0x0203
+
+#define IMX376_AGAIN_HIGH_ADDR      0x0204 //ANA gain [9:8]
+#define IMX376_AGAIN_LOW_ADDR       0x0205 //ANA gain [7:0]
+#define IMX376_DGAIN_HIGH_GR_ADDR       0x020E //DIG GR gain
+#define IMX376_DGAIN_LOW_GR_ADDR        0x020F //DIG GR gain
+#define IMX376_DGAIN_HIGH_R_ADDR        0x0210 //DIG R gain
+#define IMX376_DGAIN_LOW_R_ADDR         0x0211 //DIG R gain
+#define IMX376_DGAIN_HIGH_B_ADDR        0x0212 //DIG B gain
+#define IMX376_DGAIN_LOW_B_ADDR         0x0213 //DIG B gain
+#define IMX376_DGAIN_HIGH_GB_ADDR       0x0214 //DIG GB gain
+#define IMX376_DGAIN_LOW_GB_ADDR        0x0215 //DIG GB gain
+
+#define IMX376_VMAX_HIGH_ADDR        0x0340 //vmax
+#define IMX376_VMAX_LOW_ADDR         0x0341 //vmax
+
+#define IMX376_FLIP_MIRROR_ADDR		0x0101 //flip mirror
+
+#define IMX376_RES_IS_5M(w, h)      ((w) == SENSOR_IMX376_5M_WIDTH && (h) == SENSOR_IMX376_5M_HEIGHT)
+static CVI_S32 cmos_get_ae_default(VI_PIPE ViPipe, AE_SENSOR_DEFAULT_S *pstAeSnsDft)
+{
+	ISP_SNS_STATE_S *pstSnsState = CVI_NULL;
+
+	CMOS_CHECK_POINTER(pstAeSnsDft);
+	IMX376_SENSOR_GET_CTX(ViPipe, pstSnsState);
+	CMOS_CHECK_POINTER(pstSnsState);
+
+	pstAeSnsDft->u32FullLinesStd = pstSnsState->u32FLStd;
+	pstAeSnsDft->u32FlickerFreq = 50 * 256;
+	pstAeSnsDft->u32FullLinesMax = IMX376_FULL_LINES_MAX;
+	pstAeSnsDft->u32HmaxTimes = (1000000) / (pstSnsState->u32FLStd * g_astImx376_mode[IMX376_MODE_5M25].f32MaxFps);
+
+	pstAeSnsDft->stIntTimeAccu.enAccuType = AE_ACCURACY_LINEAR;
+	pstAeSnsDft->stIntTimeAccu.f32Accuracy = 1;
+	pstAeSnsDft->stIntTimeAccu.f32Offset = 0;
+
+	pstAeSnsDft->stAgainAccu.enAccuType = AE_ACCURACY_TABLE;
+	pstAeSnsDft->stAgainAccu.f32Accuracy = 1;
+
+	pstAeSnsDft->stDgainAccu.enAccuType = AE_ACCURACY_TABLE;
+	pstAeSnsDft->stDgainAccu.f32Accuracy = 1;
+
+	pstAeSnsDft->u32ISPDgainShift = 8;
+	pstAeSnsDft->u32MinISPDgainTarget = 1 << pstAeSnsDft->u32ISPDgainShift;
+	pstAeSnsDft->u32MaxISPDgainTarget = 2 << pstAeSnsDft->u32ISPDgainShift;
+
+	if (g_au32LinesPer500ms[ViPipe] == 0)
+		pstAeSnsDft->u32LinesPer500ms = pstSnsState->u32FLStd * g_astImx376_mode[IMX376_MODE_5M25].f32MaxFps / 2;
+	else
+		pstAeSnsDft->u32LinesPer500ms = g_au32LinesPer500ms[ViPipe];
+	pstAeSnsDft->u32SnsStableFrame = 8;
+
+	switch (pstSnsState->enWDRMode) {
+	default:
+	case WDR_MODE_NONE:   /*linear mode*/
+		pstAeSnsDft->f32Fps = g_astImx376_mode[IMX376_MODE_5M25].f32MaxFps;
+		pstAeSnsDft->f32MinFps = g_astImx376_mode[IMX376_MODE_5M25].f32MinFps;
+		pstAeSnsDft->au8HistThresh[0] = 0xd;
+		pstAeSnsDft->au8HistThresh[1] = 0x28;
+		pstAeSnsDft->au8HistThresh[2] = 0x60;
+		pstAeSnsDft->au8HistThresh[3] = 0x80;
+
+		pstAeSnsDft->u32MaxAgain = 16384;
+		pstAeSnsDft->u32MinAgain = 1024;
+		pstAeSnsDft->u32MaxAgainTarget = pstAeSnsDft->u32MaxAgain;
+		pstAeSnsDft->u32MinAgainTarget = pstAeSnsDft->u32MinAgain;
+
+		pstAeSnsDft->u32MaxDgain = 16320;
+		pstAeSnsDft->u32MinDgain = 1024;
+		pstAeSnsDft->u32MaxDgainTarget = pstAeSnsDft->u32MaxDgain;
+		pstAeSnsDft->u32MinDgainTarget = pstAeSnsDft->u32MinDgain;
+
+		pstAeSnsDft->u8AeCompensation = 40;
+		pstAeSnsDft->u32InitAESpeed = 64;
+		pstAeSnsDft->u32InitAETolerance = 5;
+		pstAeSnsDft->u32AEResponseFrame = 4;
+		pstAeSnsDft->enAeExpMode = AE_EXP_HIGHLIGHT_PRIOR;
+		pstAeSnsDft->u32InitExposure = g_au32InitExposure[ViPipe] ? g_au32InitExposure[ViPipe] : 76151;
+
+		//shutter time [5 to (number of lines perframe -1)]
+		pstAeSnsDft->u32MaxIntTime = pstSnsState->u32FLStd - 8;
+		pstAeSnsDft->u32MinIntTime = 2;
+		pstAeSnsDft->u32MaxIntTimeTarget = 65535;
+		pstAeSnsDft->u32MinIntTimeTarget = 1;
+		break;
+	}
+
+	return CVI_SUCCESS;
+}
+
+static CVI_S32 cmos_fps_set(VI_PIPE ViPipe, CVI_FLOAT f32Fps, AE_SENSOR_DEFAULT_S *pstAeSnsDft)
+{
+	ISP_SNS_STATE_S *pstSnsState = CVI_NULL;
+	CVI_U32 u32VMAX = IMX376_VMAX_8M25_LINEAR;
+	CVI_FLOAT f32MaxFps = 0;
+	CVI_FLOAT f32MinFps = 0;
+	CVI_U32 u32Vts = 0;
+	ISP_SNS_REGS_INFO_S *pstSnsRegsInfo = CVI_NULL;
+
+	CMOS_CHECK_POINTER(pstAeSnsDft);
+	IMX376_SENSOR_GET_CTX(ViPipe, pstSnsState);
+	CMOS_CHECK_POINTER(pstSnsState);
+
+	u32Vts = g_astImx376_mode[pstSnsState->u8ImgMode].u32VtsDef;
+	pstSnsRegsInfo = &pstSnsState->astSyncInfo[0].snsCfg;
+	f32MaxFps = g_astImx376_mode[pstSnsState->u8ImgMode].f32MaxFps;
+	f32MinFps = g_astImx376_mode[pstSnsState->u8ImgMode].f32MinFps;
+	if (pstSnsState->enWDRMode != WDR_MODE_NONE) {
+		u32Vts = u32Vts * 2;
+	}
+	if ((f32Fps <= f32MaxFps) && (f32Fps >= f32MinFps))
+		u32VMAX = u32Vts * f32MaxFps / DIV_0_TO_1_FLOAT(f32Fps);
+	else {
+		CVI_TRACE_SNS(CVI_DBG_ERR, "Unsupport Fps: %f\n", f32Fps);
+		return CVI_FAILURE;
+	}
+
+
+	u32VMAX = (u32VMAX > IMX376_FULL_LINES_MAX) ? IMX376_FULL_LINES_MAX : u32VMAX;
+
+	if (pstSnsState->enWDRMode == WDR_MODE_NONE) {
+		pstSnsRegsInfo->astI2cData[LINEAR_VMAX_L].u32Data = (u32VMAX & 0xFF);
+		pstSnsRegsInfo->astI2cData[LINEAR_VMAX_H].u32Data = ((u32VMAX & 0xFF00) >> 8);
+	} else {
+
+	}
+
+	if (WDR_MODE_2To1_LINE == pstSnsState->enWDRMode) {
+		/* In within FSC mode, RHS1 < 2 * (VMAX - BRL) - 1, RHS1 = 4*n+1. */
+		pstSnsState->u32FLStd = u32VMAX * 2;
+		g_astImx376_State[ViPipe].u32RHS1_MAX = (u32VMAX - 2 * g_astImx376_State[ViPipe].u32BRL) + 2;
+		if ((g_astImx376_State[ViPipe].u32RHS1_MAX % 4) != 2)
+			g_astImx376_State[ViPipe].u32RHS1_MAX =
+				(((g_astImx376_State[ViPipe].u32RHS1_MAX + 2) >> 2) << 2) - 2;
+	} else {
+		pstSnsState->u32FLStd = u32VMAX;
+	}
+
+	pstAeSnsDft->f32Fps = f32Fps;
+	pstAeSnsDft->u32LinesPer500ms = pstSnsState->u32FLStd * f32Fps / 2;
+	pstAeSnsDft->u32FullLinesStd = pstSnsState->u32FLStd;
+	pstAeSnsDft->u32MaxIntTime = pstSnsState->u32FLStd - 8;
+	pstSnsState->au32FL[0] = pstSnsState->u32FLStd;
+	pstAeSnsDft->u32FullLines = pstSnsState->au32FL[0];
+	pstAeSnsDft->u32HmaxTimes = (1000000) / (pstSnsState->u32FLStd * DIV_0_TO_1_FLOAT(f32Fps));
+
+	return CVI_SUCCESS;
+}
+
+static CVI_S32 cmos_inttime_update(VI_PIPE ViPipe, CVI_U32 *u32IntTime)
+{
+	ISP_SNS_STATE_S *pstSnsState = CVI_NULL;
+	ISP_SNS_REGS_INFO_S *pstSnsRegsInfo = CVI_NULL;
+
+	IMX376_SENSOR_GET_CTX(ViPipe, pstSnsState);
+	CMOS_CHECK_POINTER(pstSnsState);
+	CMOS_CHECK_POINTER(u32IntTime);
+	pstSnsRegsInfo = &pstSnsState->astSyncInfo[0].snsCfg;
+
+	if (WDR_MODE_2To1_LINE == pstSnsState->enWDRMode) {
+
+	} else {
+		CVI_U32 u32TmpIntTime = u32IntTime[0];
+		/* linear exposure reg range:
+		* min : 1
+		* max : vts - 4
+		* step : 1
+		*/
+		u32TmpIntTime = (u32TmpIntTime > (pstSnsState->au32FL[0] - 8)) ?
+				(pstSnsState->au32FL[0] - 8) : u32TmpIntTime;
+
+		pstSnsRegsInfo->astI2cData[LINEAR_SHR_L].u32Data = (u32TmpIntTime & 0xFF);
+		pstSnsRegsInfo->astI2cData[LINEAR_SHR_H].u32Data = ((u32TmpIntTime & 0xFF00) >> 8);
+	}
+	return CVI_SUCCESS;
+
+}
+
+static CVI_U32 gain_table[241] = {
+    /* idx: 0   …   240 对应增益 1 + idx/16 */
+     1024,  1088,  1152,  1216,  1280,  1344,  1408,  1472,
+     1536,  1600,  1664,  1728,  1792,  1856,  1920,  1984,
+     2048,  2112,  2176,  2240,  2304,  2368,  2432,  2496,
+     2560,  2624,  2688,  2752,  2816,  2880,  2944,  3008,
+     3072,  3136,  3200,  3264,  3328,  3392,  3456,  3520,
+     3584,  3648,  3712,  3776,  3840,  3904,  3968,  4032,
+     4096,  4160,  4224,  4288,  4352,  4416,  4480,  4544,
+     4608,  4672,  4736,  4800,  4864,  4928,  4992,  5056,
+     5120,  5184,  5248,  5312,  5376,  5440,  5504,  5568,
+     5632,  5696,  5760,  5824,  5888,  5952,  6016,  6080,
+     6144,  6208,  6272,  6336,  6400,  6464,  6528,  6592,
+     6656,  6720,  6784,  6848,  6912,  6976,  7040,  7104,
+     7168,  7232,  7296,  7360,  7424,  7488,  7552,  7616,
+     7680,  7744,  7808,  7872,  7936,  8000,  8064,  8128,
+     8192,  8256,  8320,  8384,  8448,  8512,  8576,  8640,
+     8704,  8768,  8832,  8896,  8960,  9024,  9088,  9152,
+     9216,  9280,  9344,  9408,  9472,  9536,  9600,  9664,
+     9728,  9792,  9856,  9920,  9984, 10048, 10112, 10176,
+    10240, 10304, 10368, 10432, 10496, 10560, 10624, 10688,
+    10752, 10816, 10880, 10944, 11008, 11072, 11136, 11200,
+    11264, 11328, 11392, 11456, 11520, 11584, 11648, 11712,
+    11776, 11840, 11904, 11968, 12032, 12096, 12160, 12224,
+    12288, 12352, 12416, 12480, 12544, 12608, 12672, 12736,
+    12800, 12864, 12928, 12992, 13056, 13120, 13184, 13248,
+    13312, 13376, 13440, 37604, 37668, 13632, 13696, 13760,
+    13824, 13888, 13952, 14016, 14080, 14144, 14208, 14272,
+    14336, 14400, 14464, 14528, 14592, 14656, 14720, 14784,
+    14848, 14912, 14976, 15040, 15104, 15168, 15232, 15296,
+    15360, 15424, 15488, 15552, 15616, 15680, 15744, 15808,
+    15872, 15936, 16000, 16064, 16128, 16192, 16256, 16320,
+    16384
+};
+
+static const CVI_U32 again_table[209] = {
+	1024, 1040, 1057, 1074, 1092, 1110, 1129, 1149, 1170, 1191, 1213, 1236, 1260, 1285, 1310, 1337, 1365, 1379, 1394, 1409,
+	1424, 1440, 1456, 1472, 1489, 1506, 1524, 1542, 1560, 1579, 1598, 1618, 1638, 1659, 1680, 1702, 1724, 1747, 1771, 1795,
+	1820, 1846, 1872, 1899, 1927, 1956, 1985, 2016, 2048, 2064, 2080, 2097, 2114, 2131, 2148, 2166, 2184, 2202, 2221, 2240,
+	2259, 2279, 2299, 2319, 2340, 2361, 2383, 2404, 2427, 2449, 2473, 2496, 2520, 2545, 2570, 2595, 2621, 2647, 2674, 2702,
+	2730, 2759, 2788, 2818, 2849, 2880, 2912, 2945, 2978, 3013, 3048, 3084, 3120, 3158, 3196, 3236, 3276, 3318, 3360, 3404,
+	3449, 3495, 3542, 3591, 3640, 3692, 3744, 3799, 3855, 3912, 3971, 4032, 4096, 4128, 4161, 4194, 4228, 4262, 4297, 4332,
+	4369, 4405, 4443, 4481, 4519, 4559, 4599, 4639, 4681, 4723, 4766, 4809, 4854, 4899, 4946, 4993, 5041, 5090, 5140, 5190,
+	5242, 5295, 5349, 5405, 5461, 5518, 5577, 5637, 5698, 5761, 5825, 5890, 5957, 6026, 6096, 6168, 6241, 6316, 6393, 6472,
+	6553, 6636, 6721, 6808, 6898, 6990, 7084, 7182, 7281, 7384, 7489, 7598, 7710, 7825, 7943, 8065, 8192, 8322, 8456, 8594,
+	8738, 8886, 9039, 9198, 9362, 9532, 9709, 9892, 10082, 10280, 10485, 10699, 10922, 11155, 11397, 11650, 11915, 12192, 12483, 12787,
+	13107, 13443, 13797, 14169, 14563, 14979, 15420, 15887, 16384
+};
+
+static CVI_S32 cmos_again_calc_table(VI_PIPE ViPipe, CVI_U32 *pu32AgainLin, CVI_U32 *pu32AgainDb)
+{
+	int i;
+
+	(void) ViPipe;
+
+	CMOS_CHECK_POINTER(pu32AgainLin);
+	CMOS_CHECK_POINTER(pu32AgainDb);
+
+	if (*pu32AgainLin >= again_table[208]) {
+		*pu32AgainLin = again_table[208];
+		*pu32AgainDb = 208;
+		return CVI_SUCCESS;
+	}
+
+	for (i = 1; i < 209; i++) {
+		if (*pu32AgainLin < again_table[i]) {
+			*pu32AgainLin = again_table[i - 1];
+			*pu32AgainDb = i - 1;
+			break;
+		}
+	}
+	return CVI_SUCCESS;
+}
+
+static CVI_S32 cmos_dgain_calc_table(VI_PIPE ViPipe, CVI_U32 *pu32DgainLin, CVI_U32 *pu32DgainDb)
+{
+	int i;
+
+	(void) ViPipe;
+
+	CMOS_CHECK_POINTER(pu32DgainLin);
+	CMOS_CHECK_POINTER(pu32DgainDb);
+
+	if (*pu32DgainLin >= gain_table[239]) {
+		*pu32DgainLin = gain_table[239];
+		*pu32DgainDb = 239;
+		return CVI_SUCCESS;
+	}
+
+	for (i = 1; i < 240; i++) {
+		if (*pu32DgainLin < gain_table[i]) {
+			*pu32DgainLin = gain_table[i - 1];
+			*pu32DgainDb = i - 1;
+			break;
+		}
+	}
+	return CVI_SUCCESS;
+}
+
+static CVI_S32 cmos_gains_update(VI_PIPE ViPipe, CVI_U32 *pu32Again, CVI_U32 *pu32Dgain)
+{
+	ISP_SNS_STATE_S *pstSnsState = CVI_NULL;
+	ISP_SNS_REGS_INFO_S *pstSnsRegsInfo = CVI_NULL;
+	CVI_U32 u32Again_val;
+	CVI_U32 u32Dgain_val_inter;
+	CVI_U32 u32Dgain_val_fraction;
+	CVI_U32 u32Again;
+	CVI_U32 u32Dgain;
+
+	IMX376_SENSOR_GET_CTX(ViPipe, pstSnsState);
+	CMOS_CHECK_POINTER(pstSnsState);
+	CMOS_CHECK_POINTER(pu32Again);
+	CMOS_CHECK_POINTER(pu32Dgain);
+	pstSnsRegsInfo = &pstSnsState->astSyncInfo[0].snsCfg;
+
+	if (pstSnsState->enWDRMode == WDR_MODE_NONE) {
+		/* linear mode */
+		u32Again = pu32Again[0];
+		u32Dgain = pu32Dgain[0];
+
+		/*Again*/
+		/*ANA_gain = 1024/(1024 - x)*/
+		/*x = 0 to 960*/
+		u32Again_val = 1024 - (1024 * 1024)/again_table[u32Again];
+		u32Dgain_val_inter = gain_table[u32Dgain]/1024;
+		u32Dgain_val_fraction = (gain_table[u32Dgain]%1024)/4;
+
+		pstSnsRegsInfo->astI2cData[LINEAR_AGAIN_H].u32Data = ((u32Again_val & 0x300) >> 8);
+		pstSnsRegsInfo->astI2cData[LINEAR_AGAIN_L].u32Data = (u32Again_val & 0xFF);
+
+		/*Dgain*/
+		/*1 + 0/256[TIMES] <= Dig_gain <= 15 + 255/256[TIMES]*/
+		pstSnsRegsInfo->astI2cData[LINEAR_DGAIN_GR_L].u32Data = (u32Dgain_val_fraction & 0xFF);
+		pstSnsRegsInfo->astI2cData[LINEAR_DGAIN_GR_H].u32Data = (u32Dgain_val_inter & 0xF);
+		pstSnsRegsInfo->astI2cData[LINEAR_DGAIN_R_L].u32Data = (u32Dgain_val_fraction & 0xFF);
+		pstSnsRegsInfo->astI2cData[LINEAR_DGAIN_R_H].u32Data = (u32Dgain_val_inter & 0xF);
+		pstSnsRegsInfo->astI2cData[LINEAR_DGAIN_B_L].u32Data = (u32Dgain_val_fraction & 0xFF);
+		pstSnsRegsInfo->astI2cData[LINEAR_DGAIN_B_H].u32Data = (u32Dgain_val_inter & 0xF);
+		pstSnsRegsInfo->astI2cData[LINEAR_DGAIN_GB_L].u32Data = (u32Dgain_val_fraction & 0xFF);
+		pstSnsRegsInfo->astI2cData[LINEAR_DGAIN_GB_H].u32Data = (u32Dgain_val_inter & 0xF);
+	} else {
+
+	}
+
+	return CVI_SUCCESS;
+}
+
+static CVI_S32 cmos_get_inttime_max(VI_PIPE ViPipe, CVI_U16 u16ManRatioEnable, CVI_U32 *au32Ratio,
+		CVI_U32 *au32IntTimeMax, CVI_U32 *au32IntTimeMin, CVI_U32 *pu32LFMaxIntTime)
+{
+	CVI_U32 u32IntTimeMaxTmp = 0, u32IntTimeMaxTmp0 = 0;
+	CVI_U32 u32RatioTmp = 0x40;
+	CVI_U32 u32ShortTimeMinLimit = 4;
+
+	ISP_SNS_STATE_S *pstSnsState = CVI_NULL;
+
+	CMOS_CHECK_POINTER(au32Ratio);
+	CMOS_CHECK_POINTER(au32IntTimeMax);
+	CMOS_CHECK_POINTER(au32IntTimeMin);
+	CMOS_CHECK_POINTER(pu32LFMaxIntTime);
+	IMX376_SENSOR_GET_CTX(ViPipe, pstSnsState);
+	CMOS_CHECK_POINTER(pstSnsState);
+	if (WDR_MODE_2To1_LINE == pstSnsState->enWDRMode) {
+		if (genFSWDRMode[ViPipe] == ISP_FSWDR_LONG_FRAME_MODE) {
+			u32IntTimeMaxTmp = pstSnsState->au32FL[0] - 10;
+			au32IntTimeMax[0] = u32IntTimeMaxTmp;
+			au32IntTimeMin[0] = u32ShortTimeMinLimit;
+			return CVI_SUCCESS;
+		}
+		u32IntTimeMaxTmp0 = ((pstSnsState->au32FL[1] - 30 - pstSnsState->au32WDRIntTime[0]) * 0x40) /
+						DIV_0_TO_1(au32Ratio[0]);
+		u32IntTimeMaxTmp  = ((pstSnsState->au32FL[0] - 30) * 0x40)  / DIV_0_TO_1(au32Ratio[0] + 0x40);
+		u32IntTimeMaxTmp = (u32IntTimeMaxTmp > u32IntTimeMaxTmp0) ? u32IntTimeMaxTmp0 : u32IntTimeMaxTmp;
+		u32IntTimeMaxTmp  = (u32IntTimeMaxTmp > (g_astImx376_State[ViPipe].u32RHS1_MAX - 3)) ?
+						(g_astImx376_State[ViPipe].u32RHS1_MAX - 3) : u32IntTimeMaxTmp;
+		u32IntTimeMaxTmp  = (!u32IntTimeMaxTmp) ? 1 : u32IntTimeMaxTmp;
+		//TODO, limit max IntTime for wdr mode temporary
+		if (u32IntTimeMaxTmp > 1000)
+			u32IntTimeMaxTmp = 1000;
+	}
+
+	if (u32IntTimeMaxTmp >= u32ShortTimeMinLimit) {
+		if (pstSnsState->enWDRMode == WDR_MODE_2To1_LINE) {
+			au32IntTimeMax[0] = u32IntTimeMaxTmp;
+			au32IntTimeMax[1] = au32IntTimeMax[0] * au32Ratio[0] >> 6;
+			au32IntTimeMax[2] = au32IntTimeMax[1] * au32Ratio[1] >> 6;
+			au32IntTimeMax[3] = au32IntTimeMax[2] * au32Ratio[2] >> 6;
+			au32IntTimeMin[0] = u32ShortTimeMinLimit;
+			au32IntTimeMin[1] = au32IntTimeMin[0] * au32Ratio[0] >> 6;
+			au32IntTimeMin[2] = au32IntTimeMin[1] * au32Ratio[1] >> 6;
+			au32IntTimeMin[3] = au32IntTimeMin[2] * au32Ratio[2] >> 6;
+		} else {
+		}
+	} else {
+		if (u16ManRatioEnable) {
+			CVI_TRACE_SNS(CVI_DBG_ERR, "Manaul ExpRatio out of range!\n");
+			return CVI_FAILURE;
+		}
+		u32IntTimeMaxTmp = u32ShortTimeMinLimit;
+
+		if (pstSnsState->enWDRMode == WDR_MODE_2To1_LINE) {
+			u32RatioTmp = 0xFFF;
+			au32IntTimeMax[0] = u32IntTimeMaxTmp;
+			au32IntTimeMax[1] = au32IntTimeMax[0] * u32RatioTmp >> 6;
+		} else {
+		}
+		au32IntTimeMin[0] = au32IntTimeMax[0];
+		au32IntTimeMin[1] = au32IntTimeMax[1];
+		au32IntTimeMin[2] = au32IntTimeMax[2];
+		au32IntTimeMin[3] = au32IntTimeMax[3];
+	}
+
+	return CVI_SUCCESS;
+}
+
+/* Only used in LINE_WDR mode */
+static CVI_S32 cmos_ae_fswdr_attr_set(VI_PIPE ViPipe, AE_FSWDR_ATTR_S *pstAeFSWDRAttr)
+{
+	CMOS_CHECK_POINTER(pstAeFSWDRAttr);
+
+	genFSWDRMode[ViPipe] = pstAeFSWDRAttr->enFSWDRMode;
+	gu32MaxTimeGetCnt[ViPipe] = 0;
+
+	return CVI_SUCCESS;
+}
+
+static CVI_S32 cmos_init_ae_exp_function(AE_SENSOR_EXP_FUNC_S *pstExpFuncs)
+{
+	CMOS_CHECK_POINTER(pstExpFuncs);
+
+	memset(pstExpFuncs, 0, sizeof(AE_SENSOR_EXP_FUNC_S));
+
+	pstExpFuncs->pfn_cmos_get_ae_default    = cmos_get_ae_default;
+	pstExpFuncs->pfn_cmos_fps_set           = cmos_fps_set;
+	//pstExpFuncs->pfn_cmos_slow_framerate_set = cmos_slow_framerate_set;
+	pstExpFuncs->pfn_cmos_inttime_update    = cmos_inttime_update;
+	pstExpFuncs->pfn_cmos_gains_update      = cmos_gains_update;
+	pstExpFuncs->pfn_cmos_again_calc_table  = cmos_again_calc_table;
+	pstExpFuncs->pfn_cmos_dgain_calc_table  = cmos_dgain_calc_table;
+	pstExpFuncs->pfn_cmos_get_inttime_max   = cmos_get_inttime_max;
+	pstExpFuncs->pfn_cmos_ae_fswdr_attr_set = cmos_ae_fswdr_attr_set;
+
+	return CVI_SUCCESS;
+}
+
+static CVI_S32 cmos_get_awb_default(VI_PIPE ViPipe, AWB_SENSOR_DEFAULT_S *pstAwbSnsDft)
+{
+	(void) ViPipe;
+
+	CMOS_CHECK_POINTER(pstAwbSnsDft);
+
+	memset(pstAwbSnsDft, 0, sizeof(AWB_SENSOR_DEFAULT_S));
+
+	pstAwbSnsDft->u16InitGgain = 1024;
+	pstAwbSnsDft->u8AWBRunInterval = 1;
+
+	return CVI_SUCCESS;
+}
+
+static CVI_S32 cmos_init_awb_exp_function(AWB_SENSOR_EXP_FUNC_S *pstExpFuncs)
+{
+	CMOS_CHECK_POINTER(pstExpFuncs);
+
+	memset(pstExpFuncs, 0, sizeof(AWB_SENSOR_EXP_FUNC_S));
+
+	pstExpFuncs->pfn_cmos_get_awb_default = cmos_get_awb_default;
+
+	return CVI_SUCCESS;
+}
+
+static CVI_S32 cmos_get_isp_default(VI_PIPE ViPipe, ISP_CMOS_DEFAULT_S *pstDef)
+{
+	(void) ViPipe;
+
+	memset(pstDef, 0, sizeof(ISP_CMOS_DEFAULT_S));
+
+	memcpy(pstDef->stNoiseCalibration.CalibrationCoef,
+		&g_stIspNoiseCalibratio, sizeof(ISP_CMOS_NOISE_CALIBRATION_S));
+	return CVI_SUCCESS;
+}
+
+static CVI_S32 cmos_get_blc_default(VI_PIPE ViPipe, ISP_CMOS_BLACK_LEVEL_S *pstBlc)
+{
+	(void) ViPipe;
+
+	CMOS_CHECK_POINTER(pstBlc);
+
+	memset(pstBlc, 0, sizeof(ISP_CMOS_BLACK_LEVEL_S));
+
+	memcpy(pstBlc,
+		&g_stIspBlcCalibratio, sizeof(ISP_CMOS_BLACK_LEVEL_S));
+	return CVI_SUCCESS;
+}
+
+static CVI_S32 cmos_get_wdr_size(VI_PIPE ViPipe, ISP_SNS_ISP_INFO_S *pstIspCfg)
+{
+	const IMX376_MODE_S *pstMode = CVI_NULL;
+	ISP_SNS_STATE_S *pstSnsState = CVI_NULL;
+
+	IMX376_SENSOR_GET_CTX(ViPipe, pstSnsState);
+	CMOS_CHECK_POINTER(pstSnsState);
+	pstMode = &g_astImx376_mode[pstSnsState->u8ImgMode];
+
+	if (pstSnsState->enWDRMode != WDR_MODE_NONE) {
+		pstIspCfg->frm_num = 2;
+		memcpy(&pstIspCfg->img_size[0], &pstMode->astImg[0], sizeof(ISP_WDR_SIZE_S));
+		memcpy(&pstIspCfg->img_size[1], &pstMode->astImg[1], sizeof(ISP_WDR_SIZE_S));
+	} else {
+		pstIspCfg->frm_num = 1;
+		memcpy(&pstIspCfg->img_size[0], &pstMode->astImg[0], sizeof(ISP_WDR_SIZE_S));
+	}
+
+	return CVI_SUCCESS;
+}
+
+static CVI_S32 cmos_set_wdr_mode(VI_PIPE ViPipe, CVI_U8 u8Mode)
+{
+	ISP_SNS_STATE_S *pstSnsState = CVI_NULL;
+
+	IMX376_SENSOR_GET_CTX(ViPipe, pstSnsState);
+	CMOS_CHECK_POINTER(pstSnsState);
+
+	pstSnsState->bSyncInit = CVI_FALSE;
+
+	switch (u8Mode) {
+	case WDR_MODE_NONE:
+
+		pstSnsState->u8ImgMode = IMX376_MODE_5M25;
+		pstSnsState->enWDRMode = WDR_MODE_NONE;
+		pstSnsState->u32FLStd = g_astImx376_mode[pstSnsState->u8ImgMode].u32VtsDef;
+		CVI_TRACE_SNS(CVI_DBG_INFO, "WDR_MODE_NONE\n");
+		break;
+	default:
+		CVI_TRACE_SNS(CVI_DBG_ERR, "Unknown mode!\n");
+		return CVI_FAILURE;
+	}
+
+	pstSnsState->au32FL[0] = pstSnsState->u32FLStd;
+	pstSnsState->au32FL[1] = pstSnsState->au32FL[0];
+	memset(pstSnsState->au32WDRIntTime, 0, sizeof(pstSnsState->au32WDRIntTime));
+
+	return CVI_SUCCESS;
+}
+
+static CVI_U32 sensor_cmp_wdr_size(ISP_SNS_ISP_INFO_S *pstWdr1, ISP_SNS_ISP_INFO_S *pstWdr2)
+{
+	CVI_U32 i;
+
+	if (pstWdr1->frm_num != pstWdr2->frm_num)
+		goto _mismatch;
+	for (i = 0; i < 2; i++) {
+		if (pstWdr1->img_size[i].stSnsSize.u32Width != pstWdr2->img_size[i].stSnsSize.u32Width)
+			goto _mismatch;
+		if (pstWdr1->img_size[i].stSnsSize.u32Height != pstWdr2->img_size[i].stSnsSize.u32Height)
+			goto _mismatch;
+		if (pstWdr1->img_size[i].stWndRect.s32X != pstWdr2->img_size[i].stWndRect.s32X)
+			goto _mismatch;
+		if (pstWdr1->img_size[i].stWndRect.s32Y != pstWdr2->img_size[i].stWndRect.s32Y)
+			goto _mismatch;
+		if (pstWdr1->img_size[i].stWndRect.u32Width != pstWdr2->img_size[i].stWndRect.u32Width)
+			goto _mismatch;
+		if (pstWdr1->img_size[i].stWndRect.u32Height != pstWdr2->img_size[i].stWndRect.u32Height)
+			goto _mismatch;
+	}
+
+	return 0;
+_mismatch:
+	return 1;
+}
+
+static CVI_S32 cmos_get_sns_regs_info(VI_PIPE ViPipe, ISP_SNS_SYNC_INFO_S *pstSnsSyncInfo)
+{
+	CVI_U32 i;
+	ISP_SNS_STATE_S *pstSnsState = CVI_NULL;
+	ISP_SNS_REGS_INFO_S *pstSnsRegsInfo = CVI_NULL;
+	ISP_SNS_SYNC_INFO_S *pstCfg0 = CVI_NULL;
+	ISP_SNS_SYNC_INFO_S *pstCfg1 = CVI_NULL;
+	ISP_I2C_DATA_S *pstI2c_data = CVI_NULL;
+
+	CMOS_CHECK_POINTER(pstSnsSyncInfo);
+	IMX376_SENSOR_GET_CTX(ViPipe, pstSnsState);
+	CMOS_CHECK_POINTER(pstSnsState);
+	pstSnsRegsInfo = &pstSnsSyncInfo->snsCfg;
+	pstCfg0 = &pstSnsState->astSyncInfo[0];
+	pstCfg1 = &pstSnsState->astSyncInfo[1];
+	pstI2c_data = pstCfg0->snsCfg.astI2cData;
+
+	if ((pstSnsState->bSyncInit == CVI_FALSE) || (pstSnsRegsInfo->bConfig == CVI_FALSE)) {
+		pstCfg0->snsCfg.enSnsType = SNS_I2C_TYPE;
+		pstCfg0->snsCfg.unComBus.s8I2cDev = g_aunImx376_BusInfo[ViPipe].s8I2cDev;
+		pstCfg0->snsCfg.u8Cfg2ValidDelayMax = 2;
+		pstCfg0->snsCfg.use_snsr_sram = CVI_TRUE;
+		pstCfg0->snsCfg.u32RegNum = LINEAR_REGS_NUM;
+
+		for (i = 0; i < pstCfg0->snsCfg.u32RegNum; i++) {
+			pstI2c_data[i].bUpdate = CVI_TRUE;
+			pstI2c_data[i].u8DevAddr = g_aunImx376_AddrInfo[ViPipe].s8I2cAddr;
+			pstI2c_data[i].u32AddrByteNum = imx376_addr_byte;
+			pstI2c_data[i].u32DataByteNum = imx376_data_byte;
+		}
+
+		switch (pstSnsState->enWDRMode) {
+		default:
+			pstI2c_data[LINEAR_HOLD_START].u32RegAddr = IMX376_HOLD_ADDR;
+			pstI2c_data[LINEAR_HOLD_START].u32Data = 1;
+			pstI2c_data[LINEAR_SHR_L].u32RegAddr = IMX376_SHR_LOW_ADDR;
+			pstI2c_data[LINEAR_SHR_H].u32RegAddr = IMX376_SHR_HIGH_ADDR;
+
+			pstI2c_data[LINEAR_AGAIN_H].u32RegAddr = IMX376_AGAIN_HIGH_ADDR;
+			pstI2c_data[LINEAR_AGAIN_L].u32RegAddr = IMX376_AGAIN_LOW_ADDR;
+			pstI2c_data[LINEAR_DGAIN_GR_L].u32RegAddr = IMX376_DGAIN_LOW_GR_ADDR;
+			pstI2c_data[LINEAR_DGAIN_GR_H].u32RegAddr = IMX376_DGAIN_HIGH_GR_ADDR;
+			pstI2c_data[LINEAR_DGAIN_R_L].u32RegAddr = IMX376_DGAIN_LOW_R_ADDR;
+			pstI2c_data[LINEAR_DGAIN_R_H].u32RegAddr = IMX376_DGAIN_HIGH_R_ADDR;
+			pstI2c_data[LINEAR_DGAIN_B_L].u32RegAddr = IMX376_DGAIN_LOW_B_ADDR;
+			pstI2c_data[LINEAR_DGAIN_B_H].u32RegAddr = IMX376_DGAIN_HIGH_B_ADDR;
+			pstI2c_data[LINEAR_DGAIN_GB_L].u32RegAddr = IMX376_DGAIN_LOW_GB_ADDR;
+			pstI2c_data[LINEAR_DGAIN_GB_H].u32RegAddr = IMX376_DGAIN_HIGH_GB_ADDR;
+			pstI2c_data[LINEAR_VMAX_L].u32RegAddr = IMX376_VMAX_LOW_ADDR;
+			pstI2c_data[LINEAR_VMAX_H].u32RegAddr = IMX376_VMAX_HIGH_ADDR ;
+			pstI2c_data[LINEAR_FLIP_MIRROR].u32RegAddr = IMX376_FLIP_MIRROR_ADDR;
+			pstI2c_data[LINEAR_HOLD_END].u32RegAddr = IMX376_HOLD_ADDR;
+			pstI2c_data[LINEAR_HOLD_END].u32Data = 0;
+			pstCfg0->ispCfg.u8DelayFrmNum = 0;
+			break;
+		}
+		pstSnsState->bSyncInit = CVI_TRUE;
+		pstCfg0->snsCfg.need_update = CVI_TRUE;
+		/* recalcualte WDR size */
+		cmos_get_wdr_size(ViPipe, &pstCfg0->ispCfg);
+		pstCfg0->ispCfg.need_update = CVI_TRUE;
+	} else {
+		pstCfg0->snsCfg.need_update = CVI_FALSE;
+		for (i = 0; i < pstCfg0->snsCfg.u32RegNum; i++) {
+			if (pstCfg0->snsCfg.astI2cData[i].u32Data == pstCfg1->snsCfg.astI2cData[i].u32Data) {
+				pstCfg0->snsCfg.astI2cData[i].bUpdate = CVI_FALSE;
+			} else {
+				pstCfg0->snsCfg.astI2cData[i].bUpdate = CVI_TRUE;
+				pstCfg0->snsCfg.need_update = CVI_TRUE;
+			}
+		}
+		if (pstCfg0->snsCfg.need_update == CVI_TRUE) {
+				pstI2c_data[LINEAR_HOLD_START].u32Data = 1;
+				pstI2c_data[LINEAR_HOLD_START].bUpdate = CVI_TRUE;
+				pstI2c_data[LINEAR_HOLD_END].u32Data = 0;
+				pstI2c_data[LINEAR_HOLD_END].bUpdate = CVI_TRUE;
+		}
+		/* check update isp crop or not */
+		pstCfg0->ispCfg.need_update = (sensor_cmp_wdr_size(&pstCfg0->ispCfg, &pstCfg1->ispCfg) ?
+				CVI_TRUE : CVI_FALSE);
+		pstCfg0->ispCfg.u8DelayFrmNum = 1;
+	}
+
+	pstSnsRegsInfo->bConfig = CVI_FALSE;
+	memcpy(pstSnsSyncInfo, &pstSnsState->astSyncInfo[0], sizeof(ISP_SNS_SYNC_INFO_S));
+	memcpy(&pstSnsState->astSyncInfo[1], &pstSnsState->astSyncInfo[0], sizeof(ISP_SNS_SYNC_INFO_S));
+	pstSnsState->au32FL[1] = pstSnsState->au32FL[0];
+
+	if (pstSnsState->enWDRMode == WDR_MODE_NONE)
+		pstCfg0->snsCfg.astI2cData[LINEAR_FLIP_MIRROR].bDropFrm = CVI_FALSE;
+
+	return CVI_SUCCESS;
+}
+
+static CVI_S32 cmos_set_image_mode(VI_PIPE ViPipe, ISP_CMOS_SENSOR_IMAGE_MODE_S *pstSensorImageMode)
+{
+	CVI_U8 u8SensorImageMode = 0;
+	ISP_SNS_STATE_S *pstSnsState = CVI_NULL;
+
+	CMOS_CHECK_POINTER(pstSensorImageMode);
+	IMX376_SENSOR_GET_CTX(ViPipe, pstSnsState);
+	CMOS_CHECK_POINTER(pstSnsState);
+
+	u8SensorImageMode = pstSnsState->u8ImgMode;
+	pstSnsState->bSyncInit = CVI_FALSE;
+
+	if (pstSensorImageMode->f32Fps <= 25) {
+		if (pstSnsState->enWDRMode == WDR_MODE_NONE) {
+			if (IMX376_RES_IS_5M(pstSensorImageMode->u16Width, pstSensorImageMode->u16Height))
+				u8SensorImageMode = IMX376_MODE_5M25;
+			else {
+				CVI_TRACE_SNS(CVI_DBG_ERR, "Not support! Width:%d, Height:%d, Fps:%f, WDRMode:%d\n",
+				       pstSensorImageMode->u16Width,
+				       pstSensorImageMode->u16Height,
+				       pstSensorImageMode->f32Fps,
+				       pstSnsState->enWDRMode);
+				return CVI_FAILURE;
+			}
+		} else if (pstSnsState->enWDRMode == WDR_MODE_2To1_LINE) {
+			CVI_TRACE_SNS(CVI_DBG_ERR, "Not support! Width:%d, Height:%d, Fps:%f, WDRMode:%d\n",
+					pstSensorImageMode->u16Width,
+					pstSensorImageMode->u16Height,
+					pstSensorImageMode->f32Fps,
+					pstSnsState->enWDRMode);
+			return CVI_FAILURE;
+		} else {
+			CVI_TRACE_SNS(CVI_DBG_ERR, "Not support! Width:%d, Height:%d, Fps:%f, WDRMode:%d\n",
+			       pstSensorImageMode->u16Width,
+			       pstSensorImageMode->u16Height,
+			       pstSensorImageMode->f32Fps,
+			       pstSnsState->enWDRMode);
+			return CVI_FAILURE;
+		}
+	} else {
+		CVI_TRACE_SNS(CVI_DBG_ERR, "Not support! Width:%d, Height:%d, Fps:%f, WDRMode:%d\n",
+				pstSensorImageMode->u16Width,
+				pstSensorImageMode->u16Height,
+				pstSensorImageMode->f32Fps,
+				pstSnsState->enWDRMode);
+		return CVI_FAILURE;
+	}
+
+	if ((pstSnsState->bInit == CVI_TRUE) && (u8SensorImageMode == pstSnsState->u8ImgMode)) {
+		return CVI_FAILURE;
+	}
+
+	pstSnsState->u8ImgMode = u8SensorImageMode;
+
+	return CVI_SUCCESS;
+}
+
+static CVI_VOID sensor_mirror_flip(VI_PIPE ViPipe, ISP_SNS_MIRRORFLIP_TYPE_E eSnsMirrorFlip)
+{
+	CVI_U8 value = 0x0;
+	CVI_U8 start_x = 0;
+	CVI_U8 start_y = 0;
+
+	ISP_SNS_STATE_S *pstSnsState = CVI_NULL;
+	ISP_SNS_REGS_INFO_S *pstSnsRegsInfo = CVI_NULL;
+	ISP_SNS_ISP_INFO_S *pstIspCfg0 = CVI_NULL;
+
+	IMX376_SENSOR_GET_CTX(ViPipe, pstSnsState);
+	CMOS_CHECK_POINTER_VOID(pstSnsState);
+
+	pstSnsRegsInfo = &pstSnsState->astSyncInfo[0].snsCfg;
+	pstIspCfg0 = &pstSnsState->astSyncInfo[0].ispCfg;
+
+	/* Apply the setting on the fly  */
+	if (pstSnsState->bInit == CVI_TRUE && g_aeImx376_MirrorFip[ViPipe] != eSnsMirrorFlip) {
+		switch (eSnsMirrorFlip) {
+		case ISP_SNS_NORMAL:
+			value = 0x0;
+			start_x = 0;
+			start_y = 0;
+			break;
+		case ISP_SNS_MIRROR:
+			value = 0x1;
+			start_x = 1;
+			start_y = 0;
+			break;
+		case ISP_SNS_FLIP:
+			value = 0x2;
+			start_x = 0;
+			start_y = 1;
+			break;
+		case ISP_SNS_MIRROR_FLIP:
+			value = 0x3;
+			start_x = 1;
+			start_y = 1;
+			break;
+		default:
+			return;
+		}
+
+		if (pstSnsState->enWDRMode == WDR_MODE_NONE) {
+			pstSnsRegsInfo->astI2cData[LINEAR_FLIP_MIRROR].u32Data = value;
+			pstSnsRegsInfo->astI2cData[LINEAR_FLIP_MIRROR].bDropFrm = 1;
+			pstSnsRegsInfo->astI2cData[LINEAR_FLIP_MIRROR].u8DropFrmNum = 2;
+		}
+		g_aeImx376_MirrorFip[ViPipe] = eSnsMirrorFlip;
+		pstIspCfg0->img_size[0].stWndRect.s32X = start_x;
+		pstIspCfg0->img_size[0].stWndRect.s32Y = start_y;
+
+	}
+}
+
+static CVI_VOID sensor_global_init(VI_PIPE ViPipe)
+{
+	ISP_SNS_STATE_S *pstSnsState = CVI_NULL;
+
+	IMX376_SENSOR_GET_CTX(ViPipe, pstSnsState);
+	CMOS_CHECK_POINTER_VOID(pstSnsState);
+
+	pstSnsState->bInit = CVI_FALSE;
+	pstSnsState->bSyncInit = CVI_FALSE;
+	pstSnsState->u8ImgMode = IMX376_MODE_5M25;
+	pstSnsState->enWDRMode = WDR_MODE_NONE;
+	pstSnsState->u32FLStd  = g_astImx376_mode[pstSnsState->u8ImgMode].u32VtsDef;
+	pstSnsState->au32FL[0] = g_astImx376_mode[pstSnsState->u8ImgMode].u32VtsDef;
+	pstSnsState->au32FL[1] = g_astImx376_mode[pstSnsState->u8ImgMode].u32VtsDef;
+
+	memset(&pstSnsState->astSyncInfo[0], 0, sizeof(ISP_SNS_SYNC_INFO_S));
+	memset(&pstSnsState->astSyncInfo[1], 0, sizeof(ISP_SNS_SYNC_INFO_S));
+}
+
+static CVI_S32 sensor_rx_attr(VI_PIPE ViPipe, SNS_COMBO_DEV_ATTR_S *pstRxAttr)
+{
+	ISP_SNS_STATE_S *pstSnsState = CVI_NULL;
+	SNS_COMBO_DEV_ATTR_S *pstRxAttrSrc = CVI_NULL;
+
+	IMX376_SENSOR_GET_CTX(ViPipe, pstSnsState);
+	IMX376_SENSOR_GET_COMBO(ViPipe, pstRxAttrSrc);
+
+	CMOS_CHECK_POINTER(pstSnsState);
+	CMOS_CHECK_POINTER(pstRxAttr);
+	CMOS_CHECK_POINTER(pstRxAttrSrc);
+
+	memcpy(pstRxAttr, pstRxAttrSrc, sizeof(*pstRxAttr));
+
+	pstRxAttr->img_size.start_x = g_astImx376_mode[pstSnsState->u8ImgMode].astImg[0].stWndRect.s32X;
+	pstRxAttr->img_size.start_y = g_astImx376_mode[pstSnsState->u8ImgMode].astImg[0].stWndRect.s32Y;
+	pstRxAttr->img_size.active_w = g_astImx376_mode[pstSnsState->u8ImgMode].astImg[0].stWndRect.u32Width;
+	pstRxAttr->img_size.active_h = g_astImx376_mode[pstSnsState->u8ImgMode].astImg[0].stWndRect.u32Height;
+	pstRxAttr->img_size.width = g_astImx376_mode[pstSnsState->u8ImgMode].astImg[0].stSnsSize.u32Width;
+	pstRxAttr->img_size.height = g_astImx376_mode[pstSnsState->u8ImgMode].astImg[0].stSnsSize.u32Height;
+	pstRxAttr->img_size.max_width = g_astImx376_mode[pstSnsState->u8ImgMode].astImg[0].stMaxSize.u32Width;
+	pstRxAttr->img_size.max_height = g_astImx376_mode[pstSnsState->u8ImgMode].astImg[0].stMaxSize.u32Height;
+
+	if (pstSnsState->enWDRMode != WDR_MODE_NONE) {
+		pstRxAttr->mac_clk = RX_MAC_CLK_600M;
+		pstRxAttr->mipi_attr.dphy.hs_settle = 10;
+	} else {
+		pstRxAttr->mipi_attr.wdr_mode = CVI_MIPI_WDR_MODE_NONE;
+	}
+	pstRxAttrSrc = CVI_NULL;
+	return CVI_SUCCESS;
+
+}
+
+static CVI_S32 sensor_patch_rx_attr(VI_PIPE ViPipe, RX_INIT_ATTR_S *pstRxInitAttr)
+{
+	int i;
+	SNS_COMBO_DEV_ATTR_S *pstRxAttr = CVI_NULL;
+
+	if (!g_pastImx376ComboDevArray[ViPipe]) {
+		pstRxAttr = malloc(sizeof(SNS_COMBO_DEV_ATTR_S));
+	} else {
+		IMX376_SENSOR_GET_COMBO(ViPipe, pstRxAttr);
+	}
+	memcpy(pstRxAttr, &imx376_rx_attr, sizeof(SNS_COMBO_DEV_ATTR_S));
+	IMX376_SENSOR_SET_COMBO(ViPipe, pstRxAttr);
+
+	CMOS_CHECK_POINTER(pstRxInitAttr);
+
+	if (pstRxInitAttr->stMclkAttr.bMclkEn)
+		pstRxAttr->mclk.cam = pstRxInitAttr->stMclkAttr.u8Mclk;
+
+	if (pstRxInitAttr->MipiDev >= VI_MAX_DEV_NUM)
+		return CVI_SUCCESS;
+
+	pstRxAttr->devno = pstRxInitAttr->MipiDev;
+	pstRxAttr->cif_mode = pstRxInitAttr->MipiMode;
+
+	if (pstRxAttr->input_mode == INPUT_MODE_MIPI) {
+		struct mipi_dev_attr_s *attr = &pstRxAttr->mipi_attr;
+
+		for (i = 0; i < MIPI_LANE_NUM + 1; i++) {
+			attr->lane_id[i] = pstRxInitAttr->as16LaneId[i];
+			attr->pn_swap[i] = pstRxInitAttr->as8PNSwap[i];
+		}
+	} else {
+		struct lvds_dev_attr_s *attr = &pstRxAttr->lvds_attr;
+
+		for (i = 0; i < MIPI_LANE_NUM + 1; i++) {
+			attr->lane_id[i] = pstRxInitAttr->as16LaneId[i];
+			attr->pn_swap[i] = pstRxInitAttr->as8PNSwap[i];
+		}
+	}
+	pstRxAttr = CVI_NULL;
+	return CVI_SUCCESS;
+}
+
+void imx376_exit(VI_PIPE ViPipe)
+{
+	if (g_pastImx376ComboDevArray[ViPipe]) {
+		free(g_pastImx376ComboDevArray[ViPipe]);
+		g_pastImx376ComboDevArray[ViPipe] = CVI_NULL;
+	}
+	imx376_i2c_exit(ViPipe);
+}
+
+static CVI_S32 cmos_init_sensor_exp_function(ISP_SENSOR_EXP_FUNC_S *pstSensorExpFunc)
+{
+	CMOS_CHECK_POINTER(pstSensorExpFunc);
+
+	memset(pstSensorExpFunc, 0, sizeof(ISP_SENSOR_EXP_FUNC_S));
+
+	pstSensorExpFunc->pfn_cmos_sensor_init = imx376_init;
+	pstSensorExpFunc->pfn_cmos_sensor_exit = imx376_exit;
+	pstSensorExpFunc->pfn_cmos_sensor_global_init = sensor_global_init;
+	pstSensorExpFunc->pfn_cmos_set_image_mode = cmos_set_image_mode;
+	pstSensorExpFunc->pfn_cmos_set_wdr_mode = cmos_set_wdr_mode;
+
+	pstSensorExpFunc->pfn_cmos_get_isp_default = cmos_get_isp_default;
+	pstSensorExpFunc->pfn_cmos_get_isp_black_level = cmos_get_blc_default;
+	pstSensorExpFunc->pfn_cmos_get_sns_reg_info = cmos_get_sns_regs_info;
+	return CVI_SUCCESS;
+}
+
+/****************************************************************************
+ * callback structure                                                       *
+ ****************************************************************************/
+static CVI_VOID sensor_patch_i2c_addr(VI_PIPE ViPipe, CVI_S32 s32I2cAddr)
+{
+	if (IMX376_I2C_ADDR_IS_VALID(s32I2cAddr))
+		g_aunImx376_AddrInfo[ViPipe].s8I2cAddr = s32I2cAddr;
+	else {
+		CVI_TRACE_SNS(CVI_DBG_ERR, "I2C addr input error ,please check [0x%x]\n", s32I2cAddr);
+		g_aunImx376_AddrInfo[ViPipe].s8I2cAddr = IMX376_I2C_ADDR_1;
+	}
+}
+
+static CVI_S32 imx376_set_bus_info(VI_PIPE ViPipe, ISP_SNS_COMMBUS_U unSNSBusInfo)
+{
+	g_aunImx376_BusInfo[ViPipe].s8I2cDev = unSNSBusInfo.s8I2cDev;
+
+	return CVI_SUCCESS;
+}
+
+static CVI_S32 sensor_ctx_init(VI_PIPE ViPipe)
+{
+	ISP_SNS_STATE_S *pastSnsStateCtx = CVI_NULL;
+
+	IMX376_SENSOR_GET_CTX(ViPipe, pastSnsStateCtx);
+
+	if (pastSnsStateCtx == CVI_NULL) {
+		pastSnsStateCtx = (ISP_SNS_STATE_S *)malloc(sizeof(ISP_SNS_STATE_S));
+		if (pastSnsStateCtx == CVI_NULL) {
+			CVI_TRACE_SNS(CVI_DBG_ERR, "Isp[%d] SnsCtx malloc memory failed!\n", ViPipe);
+			return -ENOMEM;
+		}
+	}
+
+	memset(pastSnsStateCtx, 0, sizeof(ISP_SNS_STATE_S));
+
+	IMX376_SENSOR_SET_CTX(ViPipe, pastSnsStateCtx);
+
+	return CVI_SUCCESS;
+}
+
+static CVI_VOID sensor_ctx_exit(VI_PIPE ViPipe)
+{
+	ISP_SNS_STATE_S *pastSnsStateCtx = CVI_NULL;
+
+	IMX376_SENSOR_GET_CTX(ViPipe, pastSnsStateCtx);
+	SENSOR_FREE(pastSnsStateCtx);
+	IMX376_SENSOR_RESET_CTX(ViPipe);
+	g_aeImx376_MirrorFip[ViPipe] = ISP_SNS_NORMAL;
+}
+
+static CVI_S32 sensor_register_callback(VI_PIPE ViPipe, ALG_LIB_S *pstAeLib, ALG_LIB_S *pstAwbLib)
+{
+	CVI_S32 s32Ret;
+	ISP_SENSOR_REGISTER_S stIspRegister;
+	AE_SENSOR_REGISTER_S  stAeRegister;
+	AWB_SENSOR_REGISTER_S stAwbRegister;
+	ISP_SNS_ATTR_INFO_S   stSnsAttrInfo;
+
+	CMOS_CHECK_POINTER(pstAeLib);
+	CMOS_CHECK_POINTER(pstAwbLib);
+
+	s32Ret = sensor_ctx_init(ViPipe);
+
+	if (s32Ret != CVI_SUCCESS)
+		return CVI_FAILURE;
+
+	stSnsAttrInfo.eSensorId = IMX376_ID;
+
+	s32Ret  = cmos_init_sensor_exp_function(&stIspRegister.stSnsExp);
+	s32Ret |= CVI_ISP_SensorRegCallBack(ViPipe, &stSnsAttrInfo, &stIspRegister);
+
+	if (s32Ret != CVI_SUCCESS) {
+		CVI_TRACE_SNS(CVI_DBG_ERR, "sensor register callback function failed!\n");
+		return s32Ret;
+	}
+
+	s32Ret  = cmos_init_ae_exp_function(&stAeRegister.stAeExp);
+	s32Ret |= CVI_AE_SensorRegCallBack(ViPipe, pstAeLib, &stSnsAttrInfo, &stAeRegister);
+
+	if (s32Ret != CVI_SUCCESS) {
+		CVI_TRACE_SNS(CVI_DBG_ERR, "sensor register callback function to ae lib failed!\n");
+		return s32Ret;
+	}
+
+	s32Ret  = cmos_init_awb_exp_function(&stAwbRegister.stAwbExp);
+	s32Ret |= CVI_AWB_SensorRegCallBack(ViPipe, pstAwbLib, &stSnsAttrInfo, &stAwbRegister);
+
+	if (s32Ret != CVI_SUCCESS) {
+		CVI_TRACE_SNS(CVI_DBG_ERR, "sensor register callback function to awb lib failed!\n");
+		return s32Ret;
+	}
+
+	return CVI_SUCCESS;
+}
+
+static CVI_S32 sensor_unregister_callback(VI_PIPE ViPipe, ALG_LIB_S *pstAeLib, ALG_LIB_S *pstAwbLib)
+{
+	CVI_S32 s32Ret;
+
+	CMOS_CHECK_POINTER(pstAeLib);
+	CMOS_CHECK_POINTER(pstAwbLib);
+
+	s32Ret = CVI_ISP_SensorUnRegCallBack(ViPipe, IMX376_ID);
+	if (s32Ret != CVI_SUCCESS) {
+		CVI_TRACE_SNS(CVI_DBG_ERR, "sensor unregister callback function failed!\n");
+		return s32Ret;
+	}
+
+	s32Ret = CVI_AE_SensorUnRegCallBack(ViPipe, pstAeLib, IMX376_ID);
+	if (s32Ret != CVI_SUCCESS) {
+		CVI_TRACE_SNS(CVI_DBG_ERR, "sensor unregister callback function to ae lib failed!\n");
+		return s32Ret;
+	}
+
+	s32Ret = CVI_AWB_SensorUnRegCallBack(ViPipe, pstAwbLib, IMX376_ID);
+	if (s32Ret != CVI_SUCCESS) {
+		CVI_TRACE_SNS(CVI_DBG_ERR, "sensor unregister callback function to awb lib failed!\n");
+		return s32Ret;
+	}
+
+	sensor_ctx_exit(ViPipe);
+
+	return CVI_SUCCESS;
+}
+
+static CVI_S32 sensor_set_init(VI_PIPE ViPipe, ISP_INIT_ATTR_S *pstInitAttr)
+{
+	CMOS_CHECK_POINTER(pstInitAttr);
+
+	g_au32InitExposure[ViPipe] = pstInitAttr->u32Exposure;
+	g_au32LinesPer500ms[ViPipe] = pstInitAttr->u32LinesPer500ms;
+	g_au16InitWBGain[ViPipe][0] = pstInitAttr->u16WBRgain;
+	g_au16InitWBGain[ViPipe][1] = pstInitAttr->u16WBGgain;
+	g_au16InitWBGain[ViPipe][2] = pstInitAttr->u16WBBgain;
+	g_au16SampleRgain[ViPipe] = pstInitAttr->u16SampleRgain;
+	g_au16SampleBgain[ViPipe] = pstInitAttr->u16SampleBgain;
+	g_au16Imx376_GainMode[ViPipe] = pstInitAttr->enGainMode;
+
+	return CVI_SUCCESS;
+}
+
+ISP_SNS_OBJ_S stSnsImx376_Obj = {
+	.pfnRegisterCallback    = sensor_register_callback,
+	.pfnUnRegisterCallback  = sensor_unregister_callback,
+	.pfnStandby             = imx376_standby,
+	.pfnRestart             = imx376_restart,
+	.pfnMirrorFlip          = sensor_mirror_flip,
+	.pfnWriteReg            = imx376_write_register,
+	.pfnReadReg             = imx376_read_register,
+	.pfnSetBusInfo          = imx376_set_bus_info,
+	.pfnSetInit             = sensor_set_init,
+	.pfnPatchRxAttr		= sensor_patch_rx_attr,
+	.pfnPatchI2cAddr	= sensor_patch_i2c_addr,
+	.pfnGetRxAttr		= sensor_rx_attr,
+	.pfnExpSensorCb		= cmos_init_sensor_exp_function,
+	.pfnExpAeCb		= cmos_init_ae_exp_function,
+	.pfnSnsProbe		= imx376_probe,
+};
\ No newline at end of file
diff --git a/sony_imx376/imx376_cmos_ex.h b/sony_imx376/imx376_cmos_ex.h
new file mode 100644
index 0000000..3100efe
--- /dev/null
+++ b/sony_imx376/imx376_cmos_ex.h
@@ -0,0 +1,93 @@
+#ifndef __IMX376_CMOS_EX_H_
+#define __IMX376_CMOS_EX_H_
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+#include <cvi_comm_cif.h>
+#include <cvi_type.h>
+#include "cvi_sns_ctrl.h"
+
+enum imx376_linear_regs_e {
+	LINEAR_HOLD_START = 0,
+	LINEAR_SHR_L,
+	LINEAR_SHR_H,
+	LINEAR_AGAIN_H,
+	LINEAR_AGAIN_L,
+	LINEAR_DGAIN_GR_L,
+	LINEAR_DGAIN_GR_H,
+	LINEAR_DGAIN_R_L,
+	LINEAR_DGAIN_R_H,
+	LINEAR_DGAIN_B_L,
+	LINEAR_DGAIN_B_H,
+	LINEAR_DGAIN_GB_L,
+	LINEAR_DGAIN_GB_H,
+	LINEAR_VMAX_L,
+	LINEAR_VMAX_H,
+	LINEAR_FLIP_MIRROR,
+	LINEAR_HOLD_END,
+	LINEAR_REGS_NUM
+};
+
+
+typedef enum _IMX376_MODE_E {
+	IMX376_MODE_5M25 = 0,
+	IMX376_MODE_LINEAR_NUM,
+	IMX376_MODE_NUM
+} IMX376_MODE_E;
+
+typedef struct _IMX376_STATE_S {
+	CVI_U8       u8Hcg;
+	CVI_U32      u32BRL;
+	CVI_U32      u32RHS1;
+	CVI_U32      u32RHS1_MAX;
+} IMX376_STATE_S;
+
+typedef struct _IMX376_MODE_S {
+	ISP_WDR_SIZE_S astImg[2];
+	CVI_FLOAT f32MaxFps;
+	CVI_FLOAT f32MinFps;
+	CVI_U32 u32HtsDef;
+	CVI_U32 u32VtsDef;
+	SNS_ATTR_S stExp[2];
+	SNS_ATTR_LARGE_S stAgain[2];
+	SNS_ATTR_LARGE_S stDgain[2];
+	CVI_U16 u16RHS1;
+	CVI_U16 u16BRL;
+	CVI_U16 u16OpbSize;
+	CVI_U16 u16MarginVtop;
+	CVI_U16 u16MarginVbot;
+	char name[64];
+} IMX376_MODE_S;
+
+/****************************************************************************
+ * external variables and functions                                         *
+ ****************************************************************************/
+
+extern ISP_SNS_STATE_S *g_pastImx376[VI_MAX_PIPE_NUM];
+extern ISP_SNS_COMMBUS_U g_aunImx376_BusInfo[];
+extern ISP_SNS_COMMADDR_U g_aunImx376_AddrInfo[];
+extern CVI_U16 g_au16Imx376_GainMode[];
+extern CVI_U8 imx376_i2c_addr;
+extern const CVI_U32 imx376_addr_byte;
+extern const CVI_U32 imx376_data_byte;
+extern void imx376_init(VI_PIPE ViPipe);
+extern void imx376_exit(VI_PIPE ViPipe);
+extern int imx376_i2c_exit(VI_PIPE ViPipe);
+extern void imx376_standby(VI_PIPE ViPipe);
+extern void imx376_restart(VI_PIPE ViPipe);
+extern int  imx376_write_register(VI_PIPE ViPipe, int addr, int data);
+extern int  imx376_read_register(VI_PIPE ViPipe, int addr);
+extern void imx376_mirror_flip(VI_PIPE ViPipe, ISP_SNS_MIRRORFLIP_TYPE_E eSnsMirrorFlip);
+extern int  imx376_probe(VI_PIPE ViPipe);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* End of #ifdef __cplusplus */
+
+#endif /* __IMX376_CMOS_EX_H_ */
diff --git a/sony_imx376/imx376_cmos_param.h b/sony_imx376/imx376_cmos_param.h
new file mode 100644
index 0000000..5a6968a
--- /dev/null
+++ b/sony_imx376/imx376_cmos_param.h
@@ -0,0 +1,203 @@
+#ifndef __IMX376_CMOS_PARAM_H_
+#define __IMX376_CMOS_PARAM_H_
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+#include <cvi_comm_cif.h>
+#include <cvi_type.h>
+#include "cvi_sns_ctrl.h"
+#include "imx376_cmos_ex.h"
+
+static const IMX376_MODE_S g_astImx376_mode[IMX376_MODE_NUM] = {
+	[IMX376_MODE_5M25] = {
+			.name = "IMX376_5M25",
+			.astImg[0] = {
+				.stSnsSize = {
+					.u32Width = 2564,
+					.u32Height = 1924,
+				},
+				.stWndRect = {
+					.s32X = 0,
+					.s32Y = 0,
+					.u32Width = 2560,
+					.u32Height = 1920,
+				},
+				.stMaxSize = {
+					.u32Width = 2564,
+					.u32Height = 1924,
+				},
+			},
+			.f32MaxFps = 25,
+			.f32MinFps = 0.07, /* 0x8CA * 30 / 0xFFFFF */
+			.u32HtsDef = 4572,
+			.u32VtsDef = 2384,
+			.stExp[0] = {
+				.u16Min = 5,
+				.u16Max = 2384 - 8,
+				.u16Def = 2376,
+				.u16Step = 1,
+			},
+			.stAgain[0] = {
+				.u32Min = 1024,
+				.u32Max = 16384,
+				.u32Def = 1024,
+				.u32Step = 1,
+			},
+			.stDgain[0] = {
+				.u32Min = 1024,
+				.u32Max = 16320,
+				.u32Def = 1024,
+				.u32Step = 1,
+			},
+		},
+};
+
+static ISP_CMOS_NOISE_CALIBRATION_S g_stIspNoiseCalibratio = {.CalibrationCoef = {
+	{	//iso  100
+		{0.02690107934176921844,	4.50223064422607421875}, //B: slope, intercept
+		{0.02101177349686622620,	6.80538892745971679688}, //Gb: slope, intercept
+		{0.02104613743722438812,	6.86702489852905273438}, //Gr: slope, intercept
+		{0.02316275984048843384,	5.60397005081176757813}, //R: slope, intercept
+	},
+	{	//iso  200
+		{0.03363476321101188660,	6.67160606384277343750}, //B: slope, intercept
+		{0.02475655637681484222,	9.95575618743896484375}, //Gb: slope, intercept
+		{0.02472607791423797607,	10.01574611663818359375}, //Gr: slope, intercept
+		{0.02842517755925655365,	8.12014675140380859375}, //R: slope, intercept
+	},
+	{	//iso  400
+		{0.04830884937671679688,	8.92552661895751953125}, //B: slope, intercept
+		{0.03319310769438743591,	13.42267227172851562500}, //Gb: slope, intercept
+		{0.03305986151099205017,	13.43060302734375000000}, //Gr: slope, intercept
+		{0.03901003301143646240,	11.01109695434570312500}, //R: slope, intercept
+	},
+	{	//iso  800
+		{0.06106014549732208252,	13.93724441528320312500}, //B: slope, intercept
+		{0.04092391207814216614,	20.69492340087890625000}, //Gb: slope, intercept
+		{0.04070277512073516846,	20.86536216735839843750}, //Gr: slope, intercept
+		{0.04916029050946235657,	17.03823661804199218750}, //R: slope, intercept
+	},
+	{	//iso  1600
+		{0.07344199717044830322,	24.47761344909667968750}, //B: slope, intercept
+		{0.05544847622513771057,	32.42719268798828125000}, //Gb: slope, intercept
+		{0.05420234426856040955,	33.45277023315429687500}, //Gr: slope, intercept
+		{0.06873583048582077026,	26.04830932617187500000}, //R: slope, intercept
+	},
+	{	//iso  3200
+		{0.09675583988428115845,	37.05550765991210937500}, //B: slope, intercept
+		{0.07141858339309692383,	48.99865341186523437500}, //Gb: slope, intercept
+		{0.07161217182874679565,	49.22959899902343750000}, //Gr: slope, intercept
+		{0.09100358933210372925,	39.16574478149414062500}, //R: slope, intercept
+	},
+	{	//iso  6400
+		{0.12762205302715301514,	57.20859146118164062500}, //B: slope, intercept
+		{0.09197103977203369141,	75.74417114257812500000}, //Gb: slope, intercept
+		{0.09082328528165817261,	77.31325531003769375000}, //Gr: slope, intercept
+		{0.11900347471237182617,	60.56912612915039062500}, //R: slope, intercept
+	},
+	{	//iso  12800
+		{0.18264676630496978760,	85.40633392333984375000}, //B: slope, intercept
+		{0.12531952559947967529,	115.33919525146484375000}, //Gb: slope, intercept
+		{0.12440066039562225342,	117.71653747537693750000}, //Gr: slope, intercept
+		{0.16512213647365570068,	93.01001739501953125000}, //R: slope, intercept
+	},
+	{	//iso  25600
+		{0.26012355089187622070,	128.12574768066406250000}, //B: slope, intercept
+		{0.17714048922061920166,	173.11187744140625000000}, //Gb: slope, intercept
+		{0.17438966035842895508,	178.83584594726562500000}, //Gr: slope, intercept
+		{0.23661704361438751221,	139.58770751953125000000}, //R: slope, intercept
+	},
+	{	//iso  51200
+		{0.40982273221015930176,	178.17179870605468750000}, //B: slope, intercept
+		{0.26149463653564453125,	256.04803466796875000000}, //Gb: slope, intercept
+		{0.25542837381362915039,	269.09127807617187500000}, //Gr: slope, intercept
+		{0.36157473921775817871,	202.78886437674218750000}, //R: slope, intercept
+	},
+	{	//iso  102400
+		{0.67492419481277465820,	220.58061218261718750000}, //B: slope, intercept
+		{0.47528272867202758789,	311.01812744140625000000}, //Gb: slope, intercept
+		{0.46269500255584716797,	331.09899902343750000000}, //Gr: slope, intercept
+		{0.60283488035202026367,	257.87683105468750000000}, //R: slope, intercept
+	},
+	{	//iso  204800
+		{0.84576326608657836914,	318.21844482421875000000}, //B: slope, intercept
+		{0.67934745550155639648,	410.28952026367187500000}, //Gb: slope, intercept
+		{0.63606011867523193359,	452.85031127929687500000}, //Gr: slope, intercept
+		{0.77183848619461059570,	369.87619018554687500000}, //R: slope, intercept
+	},
+	{	//iso  409600
+		{0.84576326608657836914,	318.21844482421875000000}, //B: slope, intercept
+		{0.67934745550155639648,	410.28952026367187500000}, //Gb: slope, intercept
+		{0.63606011867523193359,	452.85031127929687500000}, //Gr: slope, intercept
+		{0.77183848619461059570,	369.87619018554687500000}, //R: slope, intercept
+	},
+	{	//iso  819200
+		{0.84576326608657836914,	318.21844482421875000000}, //B: slope, intercept
+		{0.67934745550155639648,	410.28952026367187500000}, //Gb: slope, intercept
+		{0.63606011867523193359,	452.85031127929687500000}, //Gr: slope, intercept
+		{0.77183848619461059570,	369.87619018554687500000}, //R: slope, intercept
+	},
+	{	//iso  1638400
+		{0.84576326608657836914,	318.21844482421875000000}, //B: slope, intercept
+		{0.67934745550155639648,	410.28952026367187500000}, //Gb: slope, intercept
+		{0.63606011867523193359,	452.85031127929687500000}, //Gr: slope, intercept
+		{0.77183848619461059570,	369.87619018554687500000}, //R: slope, intercept
+	},
+	{	//iso  3276800
+		{0.84576326608657836914,	318.21844482421875000000}, //B: slope, intercept
+		{0.67934745550155639648,	410.28952026367187500000}, //Gb: slope, intercept
+		{0.63606011867523193359,	452.85031127929687500000}, //Gr: slope, intercept
+		{0.77183848619461059570,	369.87619018554687500000}, //R: slope, intercept
+	},
+} };
+
+static ISP_CMOS_BLACK_LEVEL_S g_stIspBlcCalibratio = {
+	.bUpdate = CVI_TRUE,
+	.blcAttr = {
+		.Enable = 1,
+		.enOpType = OP_TYPE_AUTO,
+		.stManual = {256, 256, 256, 256, 0, 0, 0, 0},
+		.stAuto = {
+			{256, 256, 256, 256, 256, 256, 256, 256, /*8*/256, 256, 256, 256, 256, 256, 256, 256},
+			{256, 256, 256, 256, 256, 256, 256, 256, /*8*/256, 256, 256, 256, 256, 256, 256, 256},
+			{256, 256, 256, 256, 256, 256, 256, 256, /*8*/256, 256, 256, 256, 256, 256, 256, 256},
+			{256, 256, 256, 256, 256, 256, 256, 256, /*8*/256, 256, 256, 256, 256, 256, 256, 256},
+			{0, 0, 0, 0, 0, 0, 0, 0, /*8*/0, 0, 0, 0, 0, 0, 0, 0},
+			{0, 0, 0, 0, 0, 0, 0, 0, /*8*/0, 0, 0, 0, 0, 0, 0, 0},
+			{0, 0, 0, 0, 0, 0, 0, 0, /*8*/0, 0, 0, 0, 0, 0, 0, 0},
+			{0, 0, 0, 0, 0, 0, 0, 0, /*8*/0, 0, 0, 0, 0, 0, 0, 0},
+		},
+	},
+};
+
+
+struct combo_dev_attr_s imx376_rx_attr = {
+	.input_mode = INPUT_MODE_MIPI,
+	.mac_clk = RX_MAC_CLK_600M,
+	.mipi_attr = {
+		.raw_data_type = RAW_DATA_10BIT,
+		.lane_id = {1, 4, 3, 0, 2},
+		.wdr_mode = CVI_MIPI_WDR_MODE_NONE,
+		.dphy = {
+			.enable = 1,
+			.hs_settle = 8,
+		},
+	},
+	.mclk = {
+		.cam = 0,
+		.freq = CAMPLL_FREQ_24M,
+	},
+	.devno = 0,
+};
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* End of #ifdef __cplusplus */
+
+#endif /* __IMX376_CMOS_PARAM_H_ */
diff --git a/sony_imx376/imx376_sensor_ctl.c b/sony_imx376/imx376_sensor_ctl.c
new file mode 100644
index 0000000..f89e99b
--- /dev/null
+++ b/sony_imx376/imx376_sensor_ctl.c
@@ -0,0 +1,526 @@
+#include <unistd.h>
+#include <cvi_comm_video.h>
+#include "cvi_sns_ctrl.h"
+#include "imx376_cmos_ex.h"
+#include "sensor_i2c.h"
+
+static void imx376_linear_5M30_init(VI_PIPE ViPipe);
+
+
+CVI_U8 imx376_i2c_addr = 0x1a;
+const CVI_U32 imx376_addr_byte = 2;
+const CVI_U32 imx376_data_byte = 1;
+
+int imx376_i2c_init(VI_PIPE ViPipe)
+{
+	return sensor_i2c_init(ViPipe, (CVI_U8)g_aunImx376_BusInfo[ViPipe].s8I2cDev,
+							(CVI_U8)g_aunImx376_AddrInfo[ViPipe].s8I2cAddr);
+}
+
+int imx376_i2c_exit(VI_PIPE ViPipe)
+{
+	return sensor_i2c_exit(ViPipe, (CVI_U8)g_aunImx376_BusInfo[ViPipe].s8I2cDev);
+}
+
+int imx376_read_register(VI_PIPE ViPipe, int addr)
+{
+	return sensor_i2c_read(ViPipe, (CVI_U8)g_aunImx376_BusInfo[ViPipe].s8I2cDev,
+							(CVI_U8)g_aunImx376_AddrInfo[ViPipe].s8I2cAddr, (CVI_U32)addr,
+							imx376_addr_byte, imx376_data_byte);
+}
+
+int imx376_write_register(VI_PIPE ViPipe, int addr, int data)
+{
+	return sensor_i2c_write(ViPipe, (CVI_U8)g_aunImx376_BusInfo[ViPipe].s8I2cDev,
+							(CVI_U8)g_aunImx376_AddrInfo[ViPipe].s8I2cAddr, (CVI_U32)addr,
+							imx376_addr_byte, (CVI_U32)data, imx376_data_byte);
+}
+
+static void delay_ms(int ms)
+{
+	usleep(ms * 1000);
+}
+
+void imx376_standby(VI_PIPE ViPipe)
+{
+	imx376_write_register(ViPipe, 0x3000, 0x01); /* STANDBY */
+	imx376_write_register(ViPipe, 0x3002, 0x01); /* XTMSTA */
+}
+
+void imx376_restart(VI_PIPE ViPipe)
+{
+	imx376_write_register(ViPipe, 0x3000, 0x00); /* standby */
+	delay_ms(20);
+	imx376_write_register(ViPipe, 0x3002, 0x00); /* master mode start */
+}
+
+void imx376_default_reg_init(VI_PIPE ViPipe)
+{
+	CVI_U32 i;
+
+	for (i = 0; i < g_pastImx376[ViPipe]->astSyncInfo[0].snsCfg.u32RegNum; i++) {
+		imx376_write_register(ViPipe,
+				g_pastImx376[ViPipe]->astSyncInfo[0].snsCfg.astI2cData[i].u32RegAddr,
+				g_pastImx376[ViPipe]->astSyncInfo[0].snsCfg.astI2cData[i].u32Data);
+	}
+}
+
+void imx376_init(VI_PIPE ViPipe)
+{
+	WDR_MODE_E        enWDRMode;
+	CVI_U8            u8ImgMode;
+
+	enWDRMode   = g_pastImx376[ViPipe]->enWDRMode;
+	u8ImgMode   = g_pastImx376[ViPipe]->u8ImgMode;
+
+	imx376_i2c_init(ViPipe);
+	if (enWDRMode == WDR_MODE_2To1_LINE) {
+		CVI_TRACE_SNS(CVI_DBG_ERR, "Unsupport image mode[%d]\n", enWDRMode);
+		return;
+	} else {
+		if (u8ImgMode == IMX376_MODE_5M25)
+			imx376_linear_5M30_init(ViPipe);
+		else {
+		}
+	}
+	g_pastImx376[ViPipe]->bInit = CVI_TRUE;
+}
+#define IMX376_CHIP_ID_HI_ADDR		0x0016
+#define IMX376_CHIP_ID_LO_ADDR		0x0017
+#define IMX376_CHIP_ID			0x376
+
+int imx376_probe(VI_PIPE ViPipe)
+{
+	int nVal;
+	CVI_U16 chip_id;
+
+	if (imx376_i2c_init(ViPipe) != CVI_SUCCESS)
+		return CVI_FAILURE;
+
+	delay_ms(5);
+
+	nVal = imx376_read_register(ViPipe, IMX376_CHIP_ID_HI_ADDR);
+	if (nVal < 0) {
+		CVI_TRACE_SNS(CVI_DBG_ERR, "read sensor id error.\n");
+		return nVal;
+	}
+	chip_id = (nVal & 0xFF) << 8;
+	nVal = imx376_read_register(ViPipe, IMX376_CHIP_ID_LO_ADDR);
+	if (nVal < 0) {
+		CVI_TRACE_SNS(CVI_DBG_ERR, "read sensor id error.\n");
+		return nVal;
+	}
+	chip_id |= (nVal & 0xFF);
+
+	if (chip_id != IMX376_CHIP_ID) {
+		CVI_TRACE_SNS(CVI_DBG_ERR, "Sensor ID Mismatch! Use the wrong sensor??\n");
+		return CVI_FAILURE;
+	}
+
+	return CVI_SUCCESS;
+}
+
+static void imx376_linear_5M30_init(VI_PIPE ViPipe)
+{
+	//MCLK: 24MHz
+	//Output Size: 2560*1920 RAW10
+	//Lane Num: 2 Lane Mipi
+	//Data Rate: 798Mbps
+	//Frame Rate: 25fps
+	//Freame Length: 2384
+	//Line Length: 6656
+	//PCLK: 397.2M
+	imx376_write_register(ViPipe, 0x0136,  0x18);
+	imx376_write_register(ViPipe, 0x0137,  0x00);
+	imx376_write_register(ViPipe, 0x3C7D,  0x28);
+	imx376_write_register(ViPipe, 0x3C7E,  0x01);
+	imx376_write_register(ViPipe, 0x3C7F,  0x08);
+	imx376_write_register(ViPipe, 0x3F02,  0x02);
+	imx376_write_register(ViPipe, 0x3F22,  0x01);
+	imx376_write_register(ViPipe, 0x3F7F,  0x01);
+	imx376_write_register(ViPipe, 0x4421,  0x04);
+	imx376_write_register(ViPipe, 0x4430,  0x05);
+	imx376_write_register(ViPipe, 0x4431,  0xDC);
+	imx376_write_register(ViPipe, 0x5222,  0x02);
+	imx376_write_register(ViPipe, 0x56B7,  0x74);
+	imx376_write_register(ViPipe, 0x6204,  0xC6);
+	imx376_write_register(ViPipe, 0x620E,  0x27);
+	imx376_write_register(ViPipe, 0x6210,  0x69);
+	imx376_write_register(ViPipe, 0x6211,  0xD6);
+	imx376_write_register(ViPipe, 0x6213,  0x01);
+	imx376_write_register(ViPipe, 0x6215,  0x5A);
+	imx376_write_register(ViPipe, 0x6216,  0x75);
+	imx376_write_register(ViPipe, 0x6218,  0x5A);
+	imx376_write_register(ViPipe, 0x6219,  0x75);
+	imx376_write_register(ViPipe, 0x6220,  0x06);
+	imx376_write_register(ViPipe, 0x6222,  0x0C);
+	imx376_write_register(ViPipe, 0x6225,  0x19);
+	imx376_write_register(ViPipe, 0x6228,  0x32);
+	imx376_write_register(ViPipe, 0x6229,  0x70);
+	imx376_write_register(ViPipe, 0x622B,  0x64);
+	imx376_write_register(ViPipe, 0x622E,  0xB0);
+	imx376_write_register(ViPipe, 0x6231,  0x71);
+	imx376_write_register(ViPipe, 0x6234,  0x06);
+	imx376_write_register(ViPipe, 0x6236,  0x46);
+	imx376_write_register(ViPipe, 0x6237,  0x46);
+	imx376_write_register(ViPipe, 0x6239,  0x0C);
+	imx376_write_register(ViPipe, 0x623C,  0x19);
+	imx376_write_register(ViPipe, 0x623F,  0x32);
+	imx376_write_register(ViPipe, 0x6240,  0x71);
+	imx376_write_register(ViPipe, 0x6242,  0x64);
+	imx376_write_register(ViPipe, 0x6243,  0x44);
+	imx376_write_register(ViPipe, 0x6245,  0xB0);
+	imx376_write_register(ViPipe, 0x6246,  0xA8);
+	imx376_write_register(ViPipe, 0x6248,  0x71);
+	imx376_write_register(ViPipe, 0x624B,  0x06);
+	imx376_write_register(ViPipe, 0x624D,  0x46);
+	imx376_write_register(ViPipe, 0x625C,  0xC9);
+	imx376_write_register(ViPipe, 0x625F,  0x92);
+	imx376_write_register(ViPipe, 0x6262,  0x26);
+	imx376_write_register(ViPipe, 0x6264,  0x46);
+	imx376_write_register(ViPipe, 0x6265,  0x46);
+	imx376_write_register(ViPipe, 0x6267,  0x0C);
+	imx376_write_register(ViPipe, 0x626A,  0x19);
+	imx376_write_register(ViPipe, 0x626D,  0x32);
+	imx376_write_register(ViPipe, 0x626E,  0x72);
+	imx376_write_register(ViPipe, 0x6270,  0x64);
+	imx376_write_register(ViPipe, 0x6271,  0x68);
+	imx376_write_register(ViPipe, 0x6273,  0xC8);
+	imx376_write_register(ViPipe, 0x6276,  0x91);
+	imx376_write_register(ViPipe, 0x6279,  0x27);
+	imx376_write_register(ViPipe, 0x627B,  0x46);
+	imx376_write_register(ViPipe, 0x627C,  0x55);
+	imx376_write_register(ViPipe, 0x627F,  0x95);
+	imx376_write_register(ViPipe, 0x6282,  0x84);
+	imx376_write_register(ViPipe, 0x6283,  0x40);
+	imx376_write_register(ViPipe, 0x6284,  0x00);
+	imx376_write_register(ViPipe, 0x6285,  0x00);
+	imx376_write_register(ViPipe, 0x6286,  0x08);
+	imx376_write_register(ViPipe, 0x6287,  0xC0);
+	imx376_write_register(ViPipe, 0x6288,  0x00);
+	imx376_write_register(ViPipe, 0x6289,  0x00);
+	imx376_write_register(ViPipe, 0x628A,  0x1B);
+	imx376_write_register(ViPipe, 0x628B,  0x80);
+	imx376_write_register(ViPipe, 0x628C,  0x20);
+	imx376_write_register(ViPipe, 0x628E,  0x35);
+	imx376_write_register(ViPipe, 0x628F,  0x00);
+	imx376_write_register(ViPipe, 0x6290,  0x50);
+	imx376_write_register(ViPipe, 0x6291,  0x00);
+	imx376_write_register(ViPipe, 0x6292,  0x14);
+	imx376_write_register(ViPipe, 0x6293,  0x00);
+	imx376_write_register(ViPipe, 0x6294,  0x00);
+	imx376_write_register(ViPipe, 0x6296,  0x54);
+	imx376_write_register(ViPipe, 0x6297,  0x00);
+	imx376_write_register(ViPipe, 0x6298,  0x00);
+	imx376_write_register(ViPipe, 0x6299,  0x01);
+	imx376_write_register(ViPipe, 0x629A,  0x10);
+	imx376_write_register(ViPipe, 0x629B,  0x01);
+	imx376_write_register(ViPipe, 0x629C,  0x00);
+	imx376_write_register(ViPipe, 0x629D,  0x03);
+	imx376_write_register(ViPipe, 0x629E,  0x50);
+	imx376_write_register(ViPipe, 0x629F,  0x05);
+	imx376_write_register(ViPipe, 0x62A0,  0x00);
+	imx376_write_register(ViPipe, 0x62B1,  0x00);
+	imx376_write_register(ViPipe, 0x62B2,  0x00);
+	imx376_write_register(ViPipe, 0x62B3,  0x00);
+	imx376_write_register(ViPipe, 0x62B5,  0x00);
+	imx376_write_register(ViPipe, 0x62B6,  0x00);
+	imx376_write_register(ViPipe, 0x62B7,  0x00);
+	imx376_write_register(ViPipe, 0x62B8,  0x00);
+	imx376_write_register(ViPipe, 0x62B9,  0x00);
+	imx376_write_register(ViPipe, 0x62BA,  0x00);
+	imx376_write_register(ViPipe, 0x62BB,  0x00);
+	imx376_write_register(ViPipe, 0x62BC,  0x00);
+	imx376_write_register(ViPipe, 0x62BD,  0x00);
+	imx376_write_register(ViPipe, 0x62BE,  0x00);
+	imx376_write_register(ViPipe, 0x62BF,  0x00);
+	imx376_write_register(ViPipe, 0x62D0,  0x0C);
+	imx376_write_register(ViPipe, 0x62D1,  0x00);
+	imx376_write_register(ViPipe, 0x62D2,  0x00);
+	imx376_write_register(ViPipe, 0x62D4,  0x40);
+	imx376_write_register(ViPipe, 0x62D5,  0x00);
+	imx376_write_register(ViPipe, 0x62D6,  0x00);
+	imx376_write_register(ViPipe, 0x62D7,  0x00);
+	imx376_write_register(ViPipe, 0x62D8,  0xD8);
+	imx376_write_register(ViPipe, 0x62D9,  0x00);
+	imx376_write_register(ViPipe, 0x62DA,  0x00);
+	imx376_write_register(ViPipe, 0x62DB,  0x02);
+	imx376_write_register(ViPipe, 0x62DC,  0xB0);
+	imx376_write_register(ViPipe, 0x62DD,  0x03);
+	imx376_write_register(ViPipe, 0x62DE,  0x00);
+	imx376_write_register(ViPipe, 0x62EF,  0x14);
+	imx376_write_register(ViPipe, 0x62F0,  0x00);
+	imx376_write_register(ViPipe, 0x62F1,  0x00);
+	imx376_write_register(ViPipe, 0x62F3,  0x58);
+	imx376_write_register(ViPipe, 0x62F4,  0x00);
+	imx376_write_register(ViPipe, 0x62F5,  0x00);
+	imx376_write_register(ViPipe, 0x62F6,  0x01);
+	imx376_write_register(ViPipe, 0x62F7,  0x20);
+	imx376_write_register(ViPipe, 0x62F8,  0x00);
+	imx376_write_register(ViPipe, 0x62F9,  0x00);
+	imx376_write_register(ViPipe, 0x62FA,  0x03);
+	imx376_write_register(ViPipe, 0x62FB,  0x80);
+	imx376_write_register(ViPipe, 0x62FC,  0x00);
+	imx376_write_register(ViPipe, 0x62FD,  0x00);
+	imx376_write_register(ViPipe, 0x62FE,  0x04);
+	imx376_write_register(ViPipe, 0x62FF,  0x60);
+	imx376_write_register(ViPipe, 0x6300,  0x04);
+	imx376_write_register(ViPipe, 0x6301,  0x00);
+	imx376_write_register(ViPipe, 0x6302,  0x09);
+	imx376_write_register(ViPipe, 0x6303,  0x00);
+	imx376_write_register(ViPipe, 0x6304,  0x0C);
+	imx376_write_register(ViPipe, 0x6305,  0x00);
+	imx376_write_register(ViPipe, 0x6306,  0x1B);
+	imx376_write_register(ViPipe, 0x6307,  0x80);
+	imx376_write_register(ViPipe, 0x6308,  0x30);
+	imx376_write_register(ViPipe, 0x630A,  0x38);
+	imx376_write_register(ViPipe, 0x630B,  0x00);
+	imx376_write_register(ViPipe, 0x630C,  0x60);
+	imx376_write_register(ViPipe, 0x630E,  0x14);
+	imx376_write_register(ViPipe, 0x630F,  0x00);
+	imx376_write_register(ViPipe, 0x6310,  0x00);
+	imx376_write_register(ViPipe, 0x6312,  0x58);
+	imx376_write_register(ViPipe, 0x6313,  0x00);
+	imx376_write_register(ViPipe, 0x6314,  0x00);
+	imx376_write_register(ViPipe, 0x6315,  0x01);
+	imx376_write_register(ViPipe, 0x6316,  0x18);
+	imx376_write_register(ViPipe, 0x6317,  0x01);
+	imx376_write_register(ViPipe, 0x6318,  0x80);
+	imx376_write_register(ViPipe, 0x6319,  0x03);
+	imx376_write_register(ViPipe, 0x631A,  0x60);
+	imx376_write_register(ViPipe, 0x631B,  0x06);
+	imx376_write_register(ViPipe, 0x631C,  0x00);
+	imx376_write_register(ViPipe, 0x632D,  0x0E);
+	imx376_write_register(ViPipe, 0x632E,  0x00);
+	imx376_write_register(ViPipe, 0x632F,  0x00);
+	imx376_write_register(ViPipe, 0x6331,  0x44);
+	imx376_write_register(ViPipe, 0x6332,  0x00);
+	imx376_write_register(ViPipe, 0x6333,  0x00);
+	imx376_write_register(ViPipe, 0x6334,  0x00);
+	imx376_write_register(ViPipe, 0x6335,  0xE8);
+	imx376_write_register(ViPipe, 0x6336,  0x00);
+	imx376_write_register(ViPipe, 0x6337,  0x00);
+	imx376_write_register(ViPipe, 0x6338,  0x02);
+	imx376_write_register(ViPipe, 0x6339,  0xF0);
+	imx376_write_register(ViPipe, 0x633A,  0x00);
+	imx376_write_register(ViPipe, 0x633B,  0x00);
+	imx376_write_register(ViPipe, 0x634C,  0x0C);
+	imx376_write_register(ViPipe, 0x634D,  0x00);
+	imx376_write_register(ViPipe, 0x634E,  0x00);
+	imx376_write_register(ViPipe, 0x6350,  0x40);
+	imx376_write_register(ViPipe, 0x6351,  0x00);
+	imx376_write_register(ViPipe, 0x6352,  0x00);
+	imx376_write_register(ViPipe, 0x6353,  0x00);
+	imx376_write_register(ViPipe, 0x6354,  0xD8);
+	imx376_write_register(ViPipe, 0x6355,  0x00);
+	imx376_write_register(ViPipe, 0x6356,  0x00);
+	imx376_write_register(ViPipe, 0x6357,  0x02);
+	imx376_write_register(ViPipe, 0x6358,  0xB0);
+	imx376_write_register(ViPipe, 0x6359,  0x04);
+	imx376_write_register(ViPipe, 0x635A,  0x00);
+	imx376_write_register(ViPipe, 0x636B,  0x00);
+	imx376_write_register(ViPipe, 0x636C,  0x00);
+	imx376_write_register(ViPipe, 0x636D,  0x00);
+	imx376_write_register(ViPipe, 0x636F,  0x00);
+	imx376_write_register(ViPipe, 0x6370,  0x00);
+	imx376_write_register(ViPipe, 0x6371,  0x00);
+	imx376_write_register(ViPipe, 0x6372,  0x00);
+	imx376_write_register(ViPipe, 0x6373,  0x00);
+	imx376_write_register(ViPipe, 0x6374,  0x00);
+	imx376_write_register(ViPipe, 0x6375,  0x00);
+	imx376_write_register(ViPipe, 0x6376,  0x00);
+	imx376_write_register(ViPipe, 0x6377,  0x00);
+	imx376_write_register(ViPipe, 0x6378,  0x00);
+	imx376_write_register(ViPipe, 0x6379,  0x00);
+	imx376_write_register(ViPipe, 0x637A,  0x13);
+	imx376_write_register(ViPipe, 0x637B,  0xD4);
+	imx376_write_register(ViPipe, 0x6388,  0x22);
+	imx376_write_register(ViPipe, 0x6389,  0x82);
+	imx376_write_register(ViPipe, 0x638A,  0xC8);
+	imx376_write_register(ViPipe, 0x639D,  0x20);
+	imx376_write_register(ViPipe, 0x7BA0,  0x01);
+	imx376_write_register(ViPipe, 0x7BA9,  0x00);
+	imx376_write_register(ViPipe, 0x7BAA,  0x01);
+	imx376_write_register(ViPipe, 0x7BAD,  0x00);
+	imx376_write_register(ViPipe, 0x9002,  0x00);
+	imx376_write_register(ViPipe, 0x9003,  0x00);
+	imx376_write_register(ViPipe, 0x9004,  0x0D);
+	imx376_write_register(ViPipe, 0x9006,  0x01);
+	imx376_write_register(ViPipe, 0x9200,  0x93);
+	imx376_write_register(ViPipe, 0x9201,  0x85);
+	imx376_write_register(ViPipe, 0x9202,  0x93);
+	imx376_write_register(ViPipe, 0x9203,  0x87);
+	imx376_write_register(ViPipe, 0x9204,  0x93);
+	imx376_write_register(ViPipe, 0x9205,  0x8D);
+	imx376_write_register(ViPipe, 0x9206,  0x93);
+	imx376_write_register(ViPipe, 0x9207,  0x8F);
+	imx376_write_register(ViPipe, 0x9208,  0x62);
+	imx376_write_register(ViPipe, 0x9209,  0x2C);
+	imx376_write_register(ViPipe, 0x920A,  0x62);
+	imx376_write_register(ViPipe, 0x920B,  0x2F);
+	imx376_write_register(ViPipe, 0x920C,  0x6A);
+	imx376_write_register(ViPipe, 0x920D,  0x23);
+	imx376_write_register(ViPipe, 0x920E,  0x71);
+	imx376_write_register(ViPipe, 0x920F,  0x08);
+	imx376_write_register(ViPipe, 0x9210,  0x71);
+	imx376_write_register(ViPipe, 0x9211,  0x09);
+	imx376_write_register(ViPipe, 0x9212,  0x71);
+	imx376_write_register(ViPipe, 0x9213,  0x0B);
+	imx376_write_register(ViPipe, 0x9214,  0x6A);
+	imx376_write_register(ViPipe, 0x9215,  0x0F);
+	imx376_write_register(ViPipe, 0x9216,  0x71);
+	imx376_write_register(ViPipe, 0x9217,  0x07);
+	imx376_write_register(ViPipe, 0x9218,  0x71);
+	imx376_write_register(ViPipe, 0x9219,  0x03);
+	imx376_write_register(ViPipe, 0x935D,  0x01);
+	imx376_write_register(ViPipe, 0x9389,  0x05);
+	imx376_write_register(ViPipe, 0x938B,  0x05);
+	imx376_write_register(ViPipe, 0x9391,  0x05);
+	imx376_write_register(ViPipe, 0x9393,  0x05);
+	imx376_write_register(ViPipe, 0x9395,  0x65);
+	imx376_write_register(ViPipe, 0x9397,  0x5A);
+	imx376_write_register(ViPipe, 0x9399,  0x05);
+	imx376_write_register(ViPipe, 0x939B,  0x05);
+	imx376_write_register(ViPipe, 0x939D,  0x05);
+	imx376_write_register(ViPipe, 0x939F,  0x05);
+	imx376_write_register(ViPipe, 0x93A1,  0x05);
+	imx376_write_register(ViPipe, 0x93A3,  0x05);
+	imx376_write_register(ViPipe, 0xB3F1,  0x80);
+	imx376_write_register(ViPipe, 0xB3F2,  0x0E);
+	imx376_write_register(ViPipe, 0xBC40,  0x03);
+	imx376_write_register(ViPipe, 0xBC82,  0x07);
+	imx376_write_register(ViPipe, 0xBC83,  0xB0);
+	imx376_write_register(ViPipe, 0xBC84,  0x0D);
+	imx376_write_register(ViPipe, 0xBC85,  0x08);
+	imx376_write_register(ViPipe, 0xE0A6,  0x0A);
+	imx376_write_register(ViPipe, 0x0100,  0x00);
+	delay_ms(50);
+	imx376_write_register(ViPipe, 0x0112,  0x0A);
+	imx376_write_register(ViPipe, 0x0113,  0x0A);
+	imx376_write_register(ViPipe, 0x0114,  0x01);
+	imx376_write_register(ViPipe, 0x0342,  0x1A);
+	imx376_write_register(ViPipe, 0x0343,  0x00);
+	imx376_write_register(ViPipe, 0x0340,  0x09);
+	imx376_write_register(ViPipe, 0x0341,  0x50);
+	imx376_write_register(ViPipe, 0x0344,  0x00);
+	imx376_write_register(ViPipe, 0x0345,  0x00);
+	imx376_write_register(ViPipe, 0x0346,  0x00);
+	imx376_write_register(ViPipe, 0x0347,  0x00);
+	imx376_write_register(ViPipe, 0x0348,  0x14);
+	imx376_write_register(ViPipe, 0x0349,  0x3F);
+	imx376_write_register(ViPipe, 0x034A,  0x0F);
+	imx376_write_register(ViPipe, 0x034B,  0x27);
+	imx376_write_register(ViPipe, 0x0381,  0x01);
+	imx376_write_register(ViPipe, 0x0383,  0x01);
+	imx376_write_register(ViPipe, 0x0385,  0x01);
+	imx376_write_register(ViPipe, 0x0387,  0x01);
+	imx376_write_register(ViPipe, 0x0900,  0x01);
+	imx376_write_register(ViPipe, 0x0901,  0x22);
+	imx376_write_register(ViPipe, 0x0902,  0x08);
+	imx376_write_register(ViPipe, 0x3F4D,  0x81);
+	imx376_write_register(ViPipe, 0x3F4C,  0x81);
+	imx376_write_register(ViPipe, 0x4254,  0x7F);
+	imx376_write_register(ViPipe, 0x0401,  0x00);
+	imx376_write_register(ViPipe, 0x0404,  0x00);
+	imx376_write_register(ViPipe, 0x0405,  0x10);
+	imx376_write_register(ViPipe, 0x0408,  0x00);
+	imx376_write_register(ViPipe, 0x0409,  0x00);
+	imx376_write_register(ViPipe, 0x040A,  0x00);
+	imx376_write_register(ViPipe, 0x040B,  0x00);
+	imx376_write_register(ViPipe, 0x040C,  0x0A);
+	imx376_write_register(ViPipe, 0x040D,  0x00);
+	imx376_write_register(ViPipe, 0x040E,  0x07);
+	imx376_write_register(ViPipe, 0x040F,  0x80);
+	imx376_write_register(ViPipe, 0x034C,  0x0A);
+	imx376_write_register(ViPipe, 0x034D,  0x04);
+	imx376_write_register(ViPipe, 0x034E,  0x07);
+	imx376_write_register(ViPipe, 0x034F,  0x84);
+	imx376_write_register(ViPipe, 0x0301,  0x05);
+	imx376_write_register(ViPipe, 0x0303,  0x04);
+	imx376_write_register(ViPipe, 0x0305,  0x04);
+	imx376_write_register(ViPipe, 0x0306,  0x01);
+	imx376_write_register(ViPipe, 0x0307,  0x4B);
+	imx376_write_register(ViPipe, 0x030B,  0x02);
+	imx376_write_register(ViPipe, 0x030D,  0x04);
+	imx376_write_register(ViPipe, 0x030E,  0x01);
+	imx376_write_register(ViPipe, 0x030F,  0x0A);
+	imx376_write_register(ViPipe, 0x0310,  0x01);
+	imx376_write_register(ViPipe, 0x0820,  0x0C);
+	imx376_write_register(ViPipe, 0x0821,  0x78);
+	imx376_write_register(ViPipe, 0x0822,  0x00);
+	imx376_write_register(ViPipe, 0x0823,  0x00);
+	imx376_write_register(ViPipe, 0xBC41,  0x01);
+	imx376_write_register(ViPipe, 0x0106,  0x00);
+	imx376_write_register(ViPipe, 0x0B00,  0x00);
+	imx376_write_register(ViPipe, 0x0B05,  0x01);
+	imx376_write_register(ViPipe, 0x0B06,  0x01);
+	imx376_write_register(ViPipe, 0x3230,  0x00);
+	imx376_write_register(ViPipe, 0x3602,  0x01);
+	imx376_write_register(ViPipe, 0x3C00,  0x74);
+	imx376_write_register(ViPipe, 0x3C01,  0x5F);
+	imx376_write_register(ViPipe, 0x3C02,  0x73);
+	imx376_write_register(ViPipe, 0x3C03,  0x64);
+	imx376_write_register(ViPipe, 0x3C04,  0x54);
+	imx376_write_register(ViPipe, 0x3C05,  0xA8);
+	imx376_write_register(ViPipe, 0x3C06,  0xBC);
+	imx376_write_register(ViPipe, 0x3C07,  0x00);
+	imx376_write_register(ViPipe, 0x3C08,  0x00);
+	imx376_write_register(ViPipe, 0x3C09,  0x01);
+	imx376_write_register(ViPipe, 0x3C0A,  0x14);
+	imx376_write_register(ViPipe, 0x3C0B,  0x01);
+	imx376_write_register(ViPipe, 0x3C0C,  0x00);
+	imx376_write_register(ViPipe, 0x3F14,  0x00);
+	imx376_write_register(ViPipe, 0x3F17,  0x00);
+	imx376_write_register(ViPipe, 0x3F3C,  0x00);
+	imx376_write_register(ViPipe, 0x3F78,  0x03);
+	imx376_write_register(ViPipe, 0x3F79,  0x84);
+	imx376_write_register(ViPipe, 0x3F7A,  0x02);
+	imx376_write_register(ViPipe, 0x3F7B,  0xFC);
+	imx376_write_register(ViPipe, 0x562B,  0x0A);
+	imx376_write_register(ViPipe, 0x562D,  0x0C);
+	imx376_write_register(ViPipe, 0x5617,  0x0A);
+	imx376_write_register(ViPipe, 0x9104,  0x04);
+	imx376_write_register(ViPipe, 0x0202,  0x09);
+	imx376_write_register(ViPipe, 0x0203,  0x48);
+	imx376_write_register(ViPipe, 0x0204,  0x00);
+	imx376_write_register(ViPipe, 0x0205,  0x00);
+	imx376_write_register(ViPipe, 0x020E,  0x01);
+	imx376_write_register(ViPipe, 0x020F,  0x00);
+	imx376_write_register(ViPipe, 0x3614,  0x00);
+	imx376_write_register(ViPipe, 0x3616,  0x0D);
+	imx376_write_register(ViPipe, 0x3617,  0x56);
+	imx376_write_register(ViPipe, 0xB612,  0x2C);
+	imx376_write_register(ViPipe, 0xB613,  0x2C);
+	imx376_write_register(ViPipe, 0xB614,  0x1C);
+	imx376_write_register(ViPipe, 0xB615,  0x1C);
+	imx376_write_register(ViPipe, 0xB616,  0x06);
+	imx376_write_register(ViPipe, 0xB617,  0x06);
+	imx376_write_register(ViPipe, 0xB618,  0x20);
+	imx376_write_register(ViPipe, 0xB619,  0x20);
+	imx376_write_register(ViPipe, 0xB61A,  0x0C);
+	imx376_write_register(ViPipe, 0xB61B,  0x0C);
+	imx376_write_register(ViPipe, 0xB61C,  0x06);
+	imx376_write_register(ViPipe, 0xB61D,  0x06);
+	imx376_write_register(ViPipe, 0xB666,  0x39);
+	imx376_write_register(ViPipe, 0xB667,  0x39);
+	imx376_write_register(ViPipe, 0xB668,  0x39);
+	imx376_write_register(ViPipe, 0xB669,  0x39);
+	imx376_write_register(ViPipe, 0xB66A,  0x13);
+	imx376_write_register(ViPipe, 0xB66B,  0x13);
+	imx376_write_register(ViPipe, 0xB66C,  0x20);
+	imx376_write_register(ViPipe, 0xB66D,  0x20);
+	imx376_write_register(ViPipe, 0xB66E,  0x20);
+	imx376_write_register(ViPipe, 0xB66F,  0x20);
+	imx376_write_register(ViPipe, 0xB670,  0x10);
+	imx376_write_register(ViPipe, 0xB671,  0x10);
+	imx376_write_register(ViPipe, 0x3900,  0x00);
+	imx376_write_register(ViPipe, 0x3901,  0x00);
+	imx376_write_register(ViPipe, 0x3237,  0x00);
+	imx376_write_register(ViPipe, 0x30AC,  0x00);
+	delay_ms(4);
+	imx376_write_register(ViPipe, 0x0100, 0x01);
+
+	imx376_default_reg_init(ViPipe);
+
+	printf("ViPipe:%d,===IMX376 5M 30fps 10bit LINEAR Init OK!===\n", ViPipe);
+}
-- 
2.25.1

