From 69d265f9395b38d7b948913f7c72b0c71373b905 Mon Sep 17 00:00:00 2001
From: "guoling.wang" <guoling.wang@sophgo.com>
Date: Fri, 31 Oct 2025 17:31:48 +0800
Subject: [PATCH] fix(vo):fix the issue where Pausechn doesn't work after
 calling ClearchnBuf

[description]:NA
[root cause]:NA
[JIRA ID]:CV184XSDK-712
[chip project]:CV184X
[side effects]:NA
[Affected *.ko/*.so/*.a] :NA

Change-Id: I89c798ba8515c79afacbd2c3eef64b3abcc6b950
---
 interdrv/vo/driver/vo_process.c   | 77 +++++++++++--------------------
 interdrv/vo/driver/vo_sdk_layer.c | 43 +++++++++++++++--
 2 files changed, 64 insertions(+), 56 deletions(-)

diff --git a/interdrv/vo/driver/vo_process.c b/interdrv/vo/driver/vo_process.c
index 626b9b5..7c05bbe 100644
--- a/interdrv/vo/driver/vo_process.c
+++ b/interdrv/vo/driver/vo_process.c
@@ -226,9 +226,6 @@ static void _vo_gdc_callback(void *gdc_param, vb_blk blk)
 	mmf_chn_s chn;
 	struct vb_jobs_t *jobs;
 	struct vb_s *vb = (struct vb_s *)(uintptr_t)blk;
-	struct disp_buffer *disp_buf;
-	unsigned char i = 0;
-	unsigned long flags;
 
 	if (!gdc_param)
 		return;
@@ -269,11 +266,6 @@ static void _vo_gdc_callback(void *gdc_param, vb_blk blk)
 	}
 	osal_atomic_set(&chn_ctx->mesh.gdc_flag, 0);
 
-	disp_buf = osal_vzalloc(sizeof(*disp_buf));
-	if (!disp_buf) {
-		TRACE_VO(DBG_ERR, "osal_vzalloc size(%zu) fail\n", sizeof(struct disp_buffer));
-		return;
-	}
 
 	osal_mutex_lock(&layer_ctx->layer_lock);
 
@@ -282,7 +274,6 @@ static void _vo_gdc_callback(void *gdc_param, vb_blk blk)
 	if (!jobs->inited) {
 		osal_mutex_unlock(&jobs->lock);
 		osal_mutex_unlock(&layer_ctx->layer_lock);
-		osal_vfree(disp_buf);
 		TRACE_VO(DBG_NOTICE, "layer(%d) chn(%d) jobs not initialized yet.\n",
 				chn.dev_id, chn.chn_id);
 		return;
@@ -307,25 +298,10 @@ static void _vo_gdc_callback(void *gdc_param, vb_blk blk)
 	osal_atomic_fetch_or(BIT(chn.mod_id), &vb->mod_ids);
 	osal_vfree(gdc_param);
 
-	disp_buf->blk = (vb_blk)(uintptr_t)vb;
-	disp_buf->buf.length = 3;
 
-	disp_buf->buf.start_x = vb->buf.offset_left;
-	disp_buf->buf.start_y = vb->buf.offset_top;
-
-	for (i = 0; i < disp_buf->buf.length; i++) {
-		disp_buf->buf.planes[i].addr = vb->buf.phy_addr[i];
-		disp_buf->buf.planes[i].bytesused = vb->buf.stride[i];
-	}
-
-	osal_spin_lock_irqsave(&layer_ctx->list_lock, &flags);
-	osal_list_add_tail(&disp_buf->list, &layer_ctx->list_wait);
-	osal_spin_unlock_irqrestore(&layer_ctx->list_lock, &flags);
 
 	osal_mutex_unlock(&layer_ctx->layer_lock);
 
-	TRACE_VO(DBG_INFO, "layer(%d) add buffer(0x%llx) to wait list.\n",
-		 layer_ctx->layer, vb->phy_addr);
 }
 
 static int _mesh_gdc_do_op_cb(enum gdc_usage usage, const void *usage_param,
@@ -441,10 +417,18 @@ static int layer_process(struct vo_layer_ctx *layer_ctx)
 		osal_vfree(disp_buf);
 	}
 
+
+	disp_buf = osal_vzalloc(sizeof(*disp_buf));
+	if (!disp_buf) {
+		TRACE_VO(DBG_ERR, "osal_vzalloc size(%zu) fail\n", sizeof(struct disp_buffer));
+		return 0;
+	}
+
 	osal_mutex_lock(&layer_ctx->layer_lock);
 	chn_num = vo_get_chn_buffers(layer_ctx, blks);
 	if (!chn_num) {
 		osal_mutex_unlock(&layer_ctx->layer_lock);
+		osal_vfree(disp_buf);
 		return 0;
 	}
 
@@ -462,8 +446,26 @@ static int layer_process(struct vo_layer_ctx *layer_ctx)
 		chn_ctx->src_height = vb->buf.size.height;
 	}
 
+	disp_buf->blk = (vb_blk)(uintptr_t)vb;
+	disp_buf->buf.length = 3;
+
+	disp_buf->buf.start_x = vb->buf.offset_left;
+	disp_buf->buf.start_y = vb->buf.offset_top;
+
+	for (i = 0; i < disp_buf->buf.length; i++) {
+		disp_buf->buf.planes[i].addr = vb->buf.phy_addr[i];
+		disp_buf->buf.planes[i].bytesused = vb->buf.stride[i];
+	}
+
+	osal_spin_lock_irqsave(&layer_ctx->list_lock, &flags);
+	osal_list_add_tail(&disp_buf->list, &layer_ctx->list_wait);
+	osal_spin_unlock_irqrestore(&layer_ctx->list_lock, &flags);
+
 	osal_mutex_unlock(&layer_ctx->layer_lock);
 
+	TRACE_VO(DBG_INFO, "layer(%d) add buffer(0x%llx) to wait list.\n",
+		layer_ctx->layer, vb->phy_addr);
+
 	if(plogodata != NULL) {
 		base_ion_free((uintptr_t)plogodata);
 		TRACE_VO(DBG_INFO, "base_ion_free, [%p]\n", plogodata);
@@ -699,9 +701,6 @@ int vo_recv_frame(mmf_chn_s chn, vb_blk blk, void *data)
 	struct vb_jobs_t *jobs;
 	struct vb_s *vb = (struct vb_s *)(uintptr_t)blk;
 	frame_rate_ctrl_s chn_frame_ctrl;
-	struct disp_buffer *disp_buf;
-	unsigned char i = 0;
-	unsigned long flags;
 	size_s size;
 
 	ret = check_vo_chn_valid(chn.dev_id, chn.chn_id);
@@ -796,12 +795,6 @@ int vo_recv_frame(mmf_chn_s chn, vb_blk blk, void *data)
 		return -1;
 	}
 
-	disp_buf = osal_vzalloc(sizeof(*disp_buf));
-	if (!disp_buf) {
-		TRACE_VO(DBG_ERR, "osal_vzalloc size(%zu) fail\n", sizeof(struct disp_buffer));
-		ret = ERR_VO_NO_MEM;
-		return ret;
-	}
 
 	osal_mutex_lock(&layer_ctx->layer_lock);
 
@@ -812,7 +805,6 @@ int vo_recv_frame(mmf_chn_s chn, vb_blk blk, void *data)
 		osal_mutex_unlock(&layer_ctx->layer_lock);
 		TRACE_VO(DBG_NOTICE, "layer(%d) chn(%d) jobs not initialized yet.\n",
 				chn.dev_id, chn.chn_id);
-		osal_vfree(disp_buf);
 		return -1;
 	}
 	if (FIFO_FULL(&jobs->waitq)) {
@@ -836,25 +828,8 @@ int vo_recv_frame(mmf_chn_s chn, vb_blk blk, void *data)
 	TRACE_VO(DBG_INFO, "layer(%d) chn(%d) push vb(0x%llx).\n",
 		 chn.dev_id, chn.chn_id, vb->phy_addr);
 
-	disp_buf->blk = (vb_blk)(uintptr_t)vb;
-	disp_buf->buf.length = 3;
-
-	disp_buf->buf.start_x = vb->buf.offset_left;
-	disp_buf->buf.start_y = vb->buf.offset_top;
-
-	for (i = 0; i < disp_buf->buf.length; i++) {
-		disp_buf->buf.planes[i].addr = vb->buf.phy_addr[i];
-		disp_buf->buf.planes[i].bytesused = vb->buf.stride[i];
-	}
-
-	osal_spin_lock_irqsave(&layer_ctx->list_lock, &flags);
-	osal_list_add_tail(&disp_buf->list, &layer_ctx->list_wait);
-	osal_spin_unlock_irqrestore(&layer_ctx->list_lock, &flags);
-
 	osal_mutex_unlock(&layer_ctx->layer_lock);
 
-	TRACE_VO(DBG_INFO, "layer(%d) add buffer(0x%llx) to wait list.\n",
-		 layer_ctx->layer, vb->phy_addr);
 
 	return ret;
 }
diff --git a/interdrv/vo/driver/vo_sdk_layer.c b/interdrv/vo/driver/vo_sdk_layer.c
index 28ee208..f015749 100644
--- a/interdrv/vo/driver/vo_sdk_layer.c
+++ b/interdrv/vo/driver/vo_sdk_layer.c
@@ -7,6 +7,7 @@
 #include "vo_process.h"
 #include "vo_sdk_layer.h"
 #include "comm_buffer.h"
+#include "ion.h"
 
 static inline int check_struct_size(unsigned int size, unsigned int type_size)
 {
@@ -1297,9 +1298,12 @@ static int vo_set_layer_proc_amp(vo_layer layer, const int *proc_amp)
 static int vo_clear_chnbuf(vo_layer layer, vo_chn chn, bool clear)
 {
 	int ret = -1;
+	int i;
 	vb_blk blk;
 	struct vo_layer_ctx *layer_ctx;
 	struct vo_chn_ctx *chn_ctx;
+	struct vb_s *vb;
+	struct vb_jobs_t *jobs;
 
 	ret = check_vo_chn_valid(layer, chn);
 	if (ret != 0)
@@ -1321,12 +1325,41 @@ static int vo_clear_chnbuf(vo_layer layer, vo_chn chn, bool clear)
 	}
 
 	//clear chn workq vb
-	while (clear && !base_mod_jobs_workq_empty(&chn_ctx->chn_jobs)) {
-		blk = base_mod_jobs_workq_pop(&chn_ctx->chn_jobs);
-		if (blk != VB_INVALID_HANDLE)
-			vb_release_block(blk);
+	if (clear && !base_mod_jobs_workq_empty(&chn_ctx->chn_jobs)) {
+
+		jobs = &chn_ctx->chn_jobs;
+		osal_mutex_lock(&jobs->lock);
+		while (FIFO_SIZE(&jobs->workq) > 1) {
+			FIFO_POP(&jobs->workq, &vb);
+			vb_release_block((vb_blk)(uintptr_t)vb);
+		}
+		FIFO_GET_FRONT(&jobs->workq, &vb);
+
+		if ((layer_ctx->layer_attr.pixformat == PIXEL_FORMAT_YUV_PLANAR_420)
+		|| (layer_ctx->layer_attr.pixformat == PIXEL_FORMAT_NV12)
+		|| (layer_ctx->layer_attr.pixformat == PIXEL_FORMAT_NV21)) {
+
+			for (i = 0; i < 3; i++) {
+				if (vb->buf.length[i] == 0)
+					continue;
+
+				if (i == 0)
+					memset(vb->vir_addr, 0x00, vb->buf.length[i]);
+				else if (i == 1)
+					memset(vb->vir_addr + vb->buf.length[0], 0x80, vb->buf.length[i]);
+				else
+					memset(vb->vir_addr + vb->buf.length[0] + vb->buf.length[1], 0x80, vb->buf.length[i]);
+
+				base_ion_cache_flush(vb->buf.phy_addr[i], vb->vir_addr, vb->buf.length[i]);
+			}
+		} else {
+			TRACE_VO(DBG_ERR, "PixFormat not support yet.\n");
+		}
+		osal_mutex_unlock(&jobs->lock);
 	}
 
+
+
 	release_buffer(layer_ctx, &layer_ctx->list_done);
 	release_buffer(layer_ctx, &layer_ctx->list_work);
 	release_buffer(layer_ctx, &layer_ctx->list_wait);
@@ -1774,7 +1807,7 @@ static int vo_pause_chn(vo_layer layer, vo_chn chn)
 
 	jobs = &chn_ctx->chn_jobs;
 	osal_mutex_lock(&jobs->lock);
-	while (FIFO_SIZE(&jobs->waitq) > 1) {
+	while (!FIFO_EMPTY(&jobs->waitq)) {
 		FIFO_POP(&jobs->waitq, &vb);
 		vb_release_block((vb_blk)(uintptr_t)vb);
 	}
-- 
2.25.1

